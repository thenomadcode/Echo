## Codebase Patterns
- Schema tables use `defineTable()` with `v` validators from "convex/values"
- Auth pattern: `authComponent.safeGetAuthUser(ctx)` returns authUser with `userId` property - always check `!authUser || !authUser.userId`
- After auth check, store userId in const: `const userId = authUser.userId;` to avoid TypeScript narrowing issues
- Owner references use `ownerId: v.string()` (not v.id) since authUser.userId is a string
- Timestamps stored as `v.number()` in UTC, populated with `Date.now()` in mutations
- Optional fields use `v.optional(v.type)` wrapper
- Enum-like fields use `v.union(v.literal("value1"), v.literal("value2"))`
- Indexes defined with `.index("indexName", ["field"])` chained after defineTable
- Nested objects use `v.object({ field: v.type })`
- Mutations use `Record<string, unknown>` for update objects to avoid optional field type conflicts
- Uniqueness validation: query by index in loop, append suffix if exists
- Queries return null/empty arrays for unauthorized access; mutations throw errors

---

## 2026-01-16 15:20 - S03: Create business queries

**What was implemented:**
- Added `businesses.list` query that returns all businesses owned by authenticated user
- Query uses the `by_owner` index for efficient lookups by ownerId
- Returns empty array for unauthenticated users
- Added `businesses.get` query that returns a single business by businessId
- Validates ownership before returning business data
- Returns null for unauthenticated users or unauthorized access attempts
- Imported query function from Convex server module

**Files changed:**
- packages/backend/convex/businesses.ts (added 43 lines, lines 134-175)
- packages/backend/convex/_generated/api.d.ts (auto-generated to include businesses module)
- AGENTS.md (added note about preferring existing shadcn/ui components)

**Learnings for future iterations:**
- When using `authUser.userId` after null check, store it in a const to avoid TypeScript type narrowing issues
- Pattern: `const userId = authUser.userId;` then use `userId` in queries
- Queries should return null or empty arrays for unauthorized/unauthenticated users rather than throwing errors
- This allows graceful handling on the client side
- Auto-generated Convex API files should be committed as they reflect the actual module exports

**Verification:**
- `bun run check-types` passed successfully
- LSP diagnostics show no errors
- Committed as: feat: S03 - Create business queries (commit 703fefb)

---


**What was implemented:**
- Created complete businesses table schema in packages/backend/convex/schema.ts
- Defined all required fields: name, slug, type (union of 4 business types)
- Defined all optional fields: description, logoUrl, address, aiGreeting
- Added localization fields: defaultLanguage, timezone (defaults will be set in mutations)
- Implemented nested businessHours object with open, close, days fields
- Added ownerId for user ownership tracking (using v.string() per auth pattern)
- Added createdAt and updatedAt timestamp fields
- Created two indexes: by_owner (for listing user's businesses) and by_slug (for unique slug lookup)

**Files changed:**
- packages/backend/convex/schema.ts (added 42 lines)

**Learnings for future iterations:**
- Auth pattern discovered: `authComponent.safeGetAuthUser(ctx)` returns authUser object with `userId` as string, so ownerId fields should use `v.string()` not `v.id("users")`
- Convex schemas don't support default values - these must be handled in mutation layer
- Convex doesn't enforce uniqueness at schema level - must validate in mutations using indexes
- Type-safe enums created using `v.union(v.literal("val1"), v.literal("val2"))`
- Schema files benefit from grouping comments for organization of large table definitions
- Business hours stored as object with time strings (HH:mm format) and days array (0-6)

**Verification:**
- `bun run check-types` passed successfully
- Committed as: feat: S01 - Create businesses table schema (commit 5c50b91)

---
## 2026-01-16 13:40 - S02: Create business mutations

**What was implemented:**
- Created businesses.create mutation with name, type, and optional fields (description, logoUrl, address)
- Implemented generateSlug() helper function to convert business name to kebab-case slug
- Added slug uniqueness validation using by_slug index with automatic suffix incrementing
- Set ownerId from authUser.userId with proper null checking
- Applied default values: defaultLanguage='en', timezone='UTC'
- Created businesses.update mutation accepting businessId and all updatable fields
- Implemented ownership validation ensuring only business owner can update
- Auto-updates updatedAt timestamp on all mutations

**Files changed:**
- packages/backend/convex/businesses.ts (created, 132 lines)

**Learnings for future iterations:**
- Must check both `!authUser` AND `!authUser.userId` since userId can be null/undefined
- Slug generation regex patterns require inline comments explaining the pattern (Priority 3 necessary comments)
- For update mutations, use `Record<string, unknown>` instead of `Partial<typeof business>` to avoid type issues with optional fields
- Uniqueness check pattern: query with index, loop until no match found, append suffix if needed
- Convex mutations throw errors which propagate to client - no need for custom error objects

---

## 2026-01-16 - S04 & S05: Create sign up and login pages

**What was implemented:**
- Created /signup route (apps/web/src/routes/signup.tsx) using TanStack Router file-based routing
- Created /login route (apps/web/src/routes/login.tsx) using TanStack Router file-based routing
- Added Google OAuth button to SignUpForm component with Better-Auth social signin
- Added Google OAuth button to SignInForm component with Better-Auth social signin
- Integrated Google logo SVG inline for OAuth buttons
- Added visual separator ("Or continue with") between email/password and OAuth options
- Updated form redirect logic (currently redirects to /dashboard; will update to /onboarding in S06)
- Generated route types using @tanstack/router-cli
- Both pages properly link to each other (signup -> login and login -> signup)

**Files changed:**
- apps/web/src/routes/signup.tsx (created, 17 lines)
- apps/web/src/routes/login.tsx (created, 17 lines)
- apps/web/src/components/sign-up-form.tsx (added Google OAuth, 50 lines added)
- apps/web/src/components/sign-in-form.tsx (added Google OAuth, 50 lines added)
- apps/web/src/routeTree.gen.ts (auto-generated route types)

**Learnings for future iterations:**
- TanStack Router requires generating route types via CLI: `bunx @tanstack/router-cli generate`
- Route types are auto-generated in `src/routeTree.gen.ts` and must be committed
- Better-Auth social signin uses `authClient.signIn.social({ provider, callbackURL })`
- Google OAuth can be triggered before route exists; callbackURL just needs to be a valid path
- For S04/S05, temporarily redirected signup to /dashboard; will update to /onboarding in S06 when that route exists
- Login redirects to /dashboard; dashboard will handle redirecting to /onboarding if user has no businesses (cleaner separation of concerns)
- Type-safe navigation with TanStack Router only allows navigating to defined routes
- Google logo inline SVG is better than importing external assets for simple icons

**Verification:**
- `bunx tsc --noEmit` in apps/web passed successfully (0 errors)
- Route generation completed without errors
- Committed as: feat: S04 - Create sign up page (commit 93c38ec)
- Updated PRD: S04 passes: true, S05 passes: true

---

## 2026-01-16 16:30 - S06: Create onboarding page for business creation

**What was implemented:**
- Created /onboarding route (apps/web/src/routes/onboarding.tsx) with protected authentication
- Used Convex's Authenticated/Unauthenticated/AuthLoading components for auth flow
- Implemented business creation form with required fields (name, type) and optional fields (description, logoUrl, address)
- Added real-time slug preview that updates as user types business name using generateSlug helper
- Native HTML select element for business type dropdown (restaurant, pharmacy, retail, other)
- Native textarea for description field
- Progress indicator showing "Step 1: Create Your Business"
- Card-based layout using shadcn/ui Card components for clean presentation
- Mobile-responsive layout with container max-width and proper spacing
- Form validation using TanStack Form without separate Zod validator (simplified approach)
- Integrated businesses.create mutation from Convex backend
- Success toast notification and redirect to /dashboard on successful submission
- Generated route types using @tanstack/router-cli

**Files changed:**
- apps/web/src/routes/onboarding.tsx (created, 280 lines)
- apps/web/src/routeTree.gen.ts (auto-generated route types update)

**Learnings for future iterations:**
- TanStack Form validation can work without explicit Zod validators by doing validation in onSubmit
- For optional fields with conditional validation (like URL), use safeParse in onSubmit handler
- Convex's Authenticated/Unauthenticated components provide cleaner auth flow than beforeLoad redirects
- Native HTML select/textarea elements work well and don't require shadcn components for simple use cases
- generateSlug helper provides live preview without needing editable slug field
- Progress indicators can be simple div-based layouts without complex step components
- Card components from shadcn/ui provide excellent structure for multi-section forms
- Route type generation must run after creating new route files
- Comments describing form sections (like "Business Name") are unnecessary - the Label components make intent clear

**Verification:**
- `bun run check-types` passed successfully (0 errors)
- LSP diagnostics show no errors after route generation
- Committed as: feat: S06 - Create onboarding page for business creation (commit f2ac337)
- Updated PRD: S06 passes: true

---

## 2026-01-16 17:00 - S07: Create dashboard page

**What was implemented:**
- Completely rebuilt /dashboard route with proper authentication and business checking
- Used Authenticated/Unauthenticated/AuthLoading pattern from Convex
- Implemented automatic redirect to /onboarding if user has no businesses using useEffect
- Dashboard displays active business (first business from businesses.list query)
- Shows business name as large heading with capitalized business type as subheading
- Created two-column card layout using shadcn/ui Card components
- Business Information card displays type, description (if available), and address (if available)
- Quick Actions card contains button linking to /settings
- Integrated UserMenu component in header area
- Clean, minimal layout with proper spacing and responsive grid
- Created placeholder /settings route to enable TypeScript type-safe navigation
- Generated route types for new settings route

**Files changed:**
- apps/web/src/routes/dashboard.tsx (rebuilt, 119 lines)
- apps/web/src/routes/settings.tsx (created placeholder, 31 lines)
- apps/web/src/routeTree.gen.ts (auto-generated route types update)

**Learnings for future iterations:**
- useEffect with navigate is ideal for conditional redirects based on query results
- Check if query is undefined before checking length to avoid unnecessary renders
- Displaying the first business as "active" is simple MVP approach; business switcher (S09) will enhance this
- Card grid with md:grid-cols-2 provides clean responsive layout without custom breakpoints
- Capitalizing enum values for display: `type.charAt(0).toUpperCase() + type.slice(1)`
- Creating placeholder routes helps avoid TypeScript navigation errors when building incrementally
- Separating DashboardContent into its own component keeps auth logic clean

**Verification:**
- `bun run check-types` passed successfully (0 errors)
- LSP diagnostics show no errors
- Committed as: feat: S07 - Create dashboard page (commit bbdcb8b)
- Updated PRD: S07 passes: true

---

## 2026-01-16 17:45 - S08: Create business settings page

**What was implemented:**
- Completely rebuilt /settings route from placeholder into fully functional settings page
- Used same auth pattern as dashboard (Authenticated/Unauthenticated/AuthLoading)
- Implemented redirect to /onboarding if user has no businesses
- Created comprehensive settings form with four Card sections:
  1. Basic Information: name, description, logoUrl
  2. Localization: defaultLanguage dropdown (en, es, pt), timezone selector
  3. Business Hours: open/close time inputs, days of week checkboxes
  4. AI Configuration: aiGreeting textarea
- Language dropdown with full language names (English, Spanish (Español), Portuguese (Português))
- Timezone selector with 15 common IANA timezones (UTC, Americas, Europe, Asia, Australia)
- Business hours uses native time inputs (HH:mm format) and checkbox grid for days
- Days of week stored as numbers (0=Sunday through 6=Saturday) matching schema
- Smart form submission only sends changed fields to businesses.update mutation
- Success toast notification on save
- Properly typed updateBusiness function with correct return type (Promise<string>)
- Mobile-responsive grid layouts (2 columns for time inputs, 2-4 columns for day checkboxes)

**Files changed:**
- apps/web/src/routes/settings.tsx (expanded from 32 to 420 lines)

**Learnings for future iterations:**
- Convex mutations return the document ID, not void - must type function signatures correctly
- Comparing arrays with JSON.stringify is pragmatic for detecting changes in simple arrays
- Native time inputs work excellently with browser UI, no need for custom time pickers
- Checkbox grids for days of week are more intuitive than multi-select dropdowns
- Smart diffing before mutation reduces unnecessary database writes
- COMMON_TIMEZONES constant provides good UX without overwhelming users
- Card-based sections make complex forms scannable and organized
- Type alias for Business interface improves readability when passing to components

**Verification:**
- `bun run check-types` passed successfully (0 errors)
- LSP diagnostics show no errors
- Committed as: feat: S08 - Create business settings page (commit 166b611)
- Updated PRD: S08 passes: true

---

## 2026-01-16 18:30 - S09: Create business switcher component

**What was implemented:**
- Created business-switcher component (apps/web/src/components/business-switcher.tsx)
- Used shadcn/ui DropdownMenu with Base UI primitives
- Button trigger displays current active business name with ChevronDown icon
- Dropdown lists all user's businesses from businesses.list query
- Each business item shows name (bold) and type (small muted text)
- Active business indicated with Check icon (checkmark) from lucide-react
- Implemented localStorage persistence with key "echo:activeBusinessId"
- Auto-selects first business if no active business is set or stored ID is invalid
- useEffect hook ensures active business is always valid when businesses list changes
- Dropdown includes separator and "Create new business" option with Plus icon
- Clicking "Create new business" navigates to /onboarding
- Integrated into dashboard page header (replaced business name heading)
- Integrated into settings page header (added to flex layout with title)
- Used render prop pattern for DropdownMenuTrigger (Base UI doesn't support asChild)

**Files changed:**
- apps/web/src/components/business-switcher.tsx (created, 90 lines)
- apps/web/src/routes/dashboard.tsx (integrated switcher, removed static business heading)
- apps/web/src/routes/settings.tsx (added switcher to header layout)

**Learnings for future iterations:**
- localStorage access must be guarded with typeof window !== "undefined" for SSR
- useEffect dependency array should include all values used for conditional logic
- Base UI DropdownMenuTrigger uses render prop pattern, not asChild like Radix UI
- Storing business ID in localStorage provides persistence across sessions
- Auto-fallback to first business provides good UX when stored ID becomes invalid
- lucide-react icons (Check, ChevronDown, Plus) integrate seamlessly with components
- Business switcher in header is more scalable than static business name display
- flex-col in dropdown items allows stacking name and metadata

**Patterns added to progress.txt:**
- Use localStorage with SSR-safe initialization: `typeof window !== "undefined"`
- DropdownMenuTrigger render prop: `render={(props) => <Button {...props}>...</Button>}`
- Active item indicator: conditional Check icon based on ID comparison

**Verification:**
- `bun run check-types` passed successfully (0 errors)
- LSP diagnostics show no errors
- Committed as: feat: S09 - Create business switcher component (commit 491aeb6)
- Updated PRD: S09 passes: true

---


## 2026-01-19 13:15 - S01: Create products and categories schema

**What was implemented:**
- Created products table in Convex schema with all required fields:
  - Relationships: businessId (v.string), categoryId (v.optional(v.string)), imageId (v.optional(v.string))
  - Required fields: name, price (v.number for centavos), currency (v.string), available (v.boolean), deleted (v.boolean), order (v.number)
  - Optional fields: description (v.optional(v.string))
  - Timestamps: createdAt, updatedAt (both v.number)
- Created categories table with all required fields:
  - Relationships: businessId (v.string)
  - Required fields: name (v.string), order (v.number)
  - Timestamps: createdAt (v.number)
- Added products indexes:
  - by_business on [businessId, deleted]
  - by_category on [categoryId, deleted, available]
- Added categories index:
  - by_business on [businessId]
- Price stored as v.number (integer representing centavos)
- Currency stored as v.string (defaults will be handled in mutations: COP, BRL, MXN, USD)

**Files changed:**
- packages/backend/convex/schema.ts (added 37 lines for products and categories tables)

**Learnings for future iterations:**
- Products table needs all fields for comprehensive product management (name, description, price, currency, category, image, availability, soft delete)
- Categories table is simpler with just business relationship, name, and order for reordering
- Multi-field indexes improve query performance (e.g., by_business on [businessId, deleted] allows filtering non-deleted products efficiently)
- Composite index on [categoryId, deleted, available] enables fast filtered queries by category and availability
- Price as integer (centavos) prevents floating-point precision issues with currency
- Currency stored as string allows flexibility for different markets without schema changes
- Soft delete pattern (deleted: boolean) preserves data integrity and allows recovery

**Verification:**
- `bun run check-types` passed successfully (0 errors)
- Committed as: feat: S01 - Create products and categories schema (commit 8db5079)
- Updated PRD: S01 passes: true

---

## 2026-01-19 13:20 - S02: Create categories backend functions

**What was implemented:**
- Created packages/backend/convex/categories.ts with complete CRUD operations
- Implemented categories.create mutation with businessId, name, order args
- Implemented categories.update mutation with categoryId, optional name and order args
- Implemented categories.deleteCategory mutation with categoryId arg (hard delete)
- Implemented categories.list query with businessId arg, returns categories sorted by order
- Implemented categories.reorder mutation with businessId and orderedIds args for drag-and-drop reordering
- All mutations validate authentication using authComponent.safeGetAuthUser pattern
- All mutations verify business ownership before allowing operations
- List query returns empty array for unauthenticated/unauthorized users
- Queries use by_business index for efficient lookups

**Files changed:**
- packages/backend/convex/categories.ts (created, 180 lines)

**Learnings for future iterations:**
- Business access validation pattern: query businesses table by _id using filter + eq, then check ownerId matches authUser._id
- For queries, return empty arrays for unauthorized access (graceful degradation)
- For mutations, throw errors for unauthorized access (fail fast)
- Named export `deleteCategory` instead of `delete` to avoid conflicts with reserved keyword
- Reorder mutation updates order field by iterating through orderedIds array with index
- Sort categories in list query using .sort((a, b) => a.order - b.order) for consistent ordering
- Use Record<string, unknown> type for update objects to avoid optional field conflicts

**Verification:**
- `bun run check-types` passed successfully (0 errors)
- Committed as: feat: S02 - Create categories backend functions (commit c50da7c)
- Updated PRD: S02 passes: true

---

## 2026-01-19 13:35 - S03: Create products CRUD backend functions

**What was implemented:**
- Created products.ts in packages/backend/convex/ with complete CRUD operations (250 lines)
- Implemented products.create mutation with businessId, name, description, price, categoryId, imageId args
- Auto-generates currency from business defaultLanguage (es->COP, pt->BRL, default->USD)
- Auto-increments order field for new products based on existing max order
- Implemented products.update mutation with productId and all optional fields (name, description, price, categoryId, imageId, available)
- Implemented products.deleteProduct mutation with soft delete (sets deleted: true, updates updatedAt)
- Implemented products.get query with productId arg, returns null for unauthenticated/unauthorized users
- Implemented products.list query with comprehensive filtering:
  - businessId (required), categoryId (optional), available (optional), search (optional)
  - Pagination support with limit and cursor args
  - Search filters by name and description (case-insensitive)
  - Returns object with products array, hasMore boolean, nextCursor number
- All queries use by_business index with [businessId, deleted] for efficient lookups
- List query excludes deleted products by default (deleted: false in index query)
- New products default to available: true, deleted: false
- All mutations validate authentication and business ownership before operations

**Files changed:**
- packages/backend/convex/products.ts (created, 250 lines)

**Learnings for future iterations:**
- Currency inference pattern: Use business.defaultLanguage to set appropriate currency (es->COP, pt->BRL, else USD)
- Order field auto-increment: Query all products, find max order, increment by 1 for new product
- Soft delete pattern: Don't actually delete from DB, just set deleted: true and update timestamp
- List query pagination: Return object with { products, hasMore, nextCursor } for client-side pagination
- Search implementation: Filter in-memory after index query (Convex doesn't support full-text search on indexed queries)
- Composite index usage: .withIndex("by_business", q => q.eq("businessId", x).eq("deleted", false)) efficiently excludes deleted items
- Named export for delete: Use deleteProduct instead of delete to avoid reserved keyword conflicts

**Verification:**
- `bun run check-types` passed successfully (0 errors)
- Committed as: feat: S03 - Create products CRUD backend functions (commit ef921a9)
- Updated PRD: S03 passes: true

---

## 2026-01-19 13:45 - S04: Create image upload backend functions

**What was implemented:**
- Created products.generateUploadUrl mutation in packages/backend/convex/products.ts
- Mutation validates authentication using authComponent.safeGetAuthUser pattern
- Returns upload URL from ctx.storage.generateUploadUrl() for client-side file upload
- Created products.getImageUrl query with storageId arg
- Query validates authentication before returning public URL
- Uses ctx.storage.getUrl(storageId) to retrieve public URL from Convex file storage
- Product imageId can already be updated via existing products.update mutation
- All file storage operations require authenticated users

**Files changed:**
- packages/backend/convex/products.ts (added 26 lines for image upload functions)

**Learnings for future iterations:**
- Convex file storage pattern: ctx.storage.generateUploadUrl() generates temporary upload URL for client
- Client uploads file to the URL, receives storageId in response
- Store storageId as string in database (imageId field)
- Retrieve public URL with ctx.storage.getUrl(storageId) when needed
- Upload URL generation should be authenticated to prevent abuse
- getImageUrl query validates auth but could be made public if product images should be accessible to customers
- File storage IDs are strings (not v.id type), use v.optional(v.string()) in schema

**Verification:**
- LSP diagnostics show no TypeScript errors
- Committed as: feat: S04 - Create image upload backend functions (commit 0955b72)
- Updated PRD: S04 passes: true

---

## 2026-01-19 13:50 - S05: Create bulk operations backend functions

**What was implemented:**
- Created products.bulkUpdateAvailability mutation accepting productIds array and available boolean
- Created products.bulkDelete mutation accepting productIds array (soft delete pattern)
- Created products.bulkUpdateCategory mutation accepting productIds array and optional categoryId
- All bulk mutations iterate through productIds array and validate ownership for each product
- Each mutation checks authentication using authComponent.safeGetAuthUser
- For each product, verifies business ownership matches authenticated user before updating
- Throws error if user doesn't own business associated with ANY product (fail-fast validation)
- Updates updatedAt timestamp for all modified products
- Returns integer count of successfully updated products
- Bulk delete sets deleted: true (soft delete), consistent with single delete pattern

**Files changed:**
- packages/backend/convex/products.ts (added 134 lines for bulk operations)

**Learnings for future iterations:**
- Bulk operations pattern: iterate through array, validate each item, track success count
- Fail-fast on authorization errors to prevent partial updates across tenant boundaries
- Skip non-existent products (continue loop) but throw on authorization failures
- Bulk mutations return count instead of IDs for simpler client handling
- Consistent timestamp updates across all bulk operations
- Bulk operations reuse same business ownership validation as single operations
- categoryId can be v.optional to support "remove from category" use case

**Verification:**
- LSP diagnostics show no TypeScript errors
- Committed as: feat: S05 - Create bulk operations backend functions (commit 7bd63c6)
- Updated PRD: S05 passes: true

---

## 2026-01-19 14:40 - S06: Create CategoryManager component and page

**What was implemented:**
- Created CategoryManager component in apps/web/src/components/products/CategoryManager.tsx (245 lines)
- Created category management page at apps/web/src/routes/products/categories.tsx (79 lines)
- Component displays list of categories with product count for each category
- Create category form with name field inline in Card component
- Edit category inline with Input field and Save/Cancel buttons
- Delete category with confirmation dialog (modal overlay)
- Product count calculation for each category using products.list query
- Uncategorized products count shown at bottom of list with special styling (bg-muted/50)
- Empty state card shown when no categories exist with helpful message
- Uses Convex queries: categories.list and products.list
- Uses Convex mutations: categories.create, categories.update, categories.deleteCategory
- Toast notifications for all success/error states
- Back to Dashboard button with ArrowLeft icon for navigation
- Auth flow with Authenticated/Unauthenticated/AuthLoading components
- Redirect to onboarding if no businesses exist
- Generated TanStack Router types for /products/categories route

**Files changed:**
- apps/web/src/components/products/CategoryManager.tsx (created, 245 lines)
- apps/web/src/routes/products/categories.tsx (created, 79 lines)
- apps/web/src/routeTree.gen.ts (auto-generated route types)
- Created directories: apps/web/src/components/products and apps/web/src/routes/products

**Learnings for future iterations:**
- CategoryManager accepts businessId prop for multi-tenant isolation
- Product count calculated client-side by filtering products.products array
- Inline editing pattern: track editingId state, show Input when editing, normal display otherwise
- Modal overlay pattern: use fixed inset-0 with bg-black/50 for simple dialogs
- Delete confirmation requires explicit state (deleteConfirmId) to show/hide dialog
- Uncategorized products filter: products.filter(p => !p.categoryId)
- lucide-react icons (Pencil, Trash2, ArrowLeft) integrate seamlessly
- TanStack Router requires bunx @tanstack/router-cli generate after adding new routes
- Convex dev --once regenerates API types when backend functions change

**Verification:**
- LSP diagnostics show no TypeScript errors after route generation
- Committed as: feat: S06 - Create CategoryManager component and page (commit e08c97a)
- Updated PRD: S06 passes: true

---

## 2026-01-19 14:45 - S07: Create PriceInput component

**What was implemented:**
- Created PriceInput component in apps/web/src/components/ui/PriceInput.tsx (116 lines)
- Component accepts currency prop (COP, BRL, MXN, USD)
- Displays appropriate currency symbol ($, R$) in left position using absolute positioning
- Currency symbols mapped: COP=$, BRL=R$, MXN=$, USD=$
- Locale-specific formatting using Intl.NumberFormat with locales: es-CO, pt-BR, es-MX, en-US
- Handles decimal input validation with regex /^[\d.]*$/
- Converts display value to centavos (integer) internally using Math.round(value * 100)
- Formats display value with thousand separators and 2 decimal places
- Focus/blur behavior: shows raw decimal on focus, formatted with separators on blur
- Controlled input with value (number in centavos) and onChange (valueInCents: number) props
- Uses forwardRef for ref forwarding to underlying Input component
- Additional props: className, id, name, placeholder, disabled
- Input mode set to "decimal" for mobile numeric keyboard

**Files changed:**
- apps/web/src/components/ui/PriceInput.tsx (created, 116 lines)

**Learnings for future iterations:**
- Price values stored as integers (centavos) prevent floating-point precision issues
- Intl.NumberFormat provides locale-aware thousand separators and decimal formatting
- Focus state controls display format: raw decimal when editing, formatted when not focused
- Currency symbol positioned absolutely with pl-8 to offset Input padding
- forwardRef required for components wrapping Input to support form refs
- inputMode="decimal" triggers appropriate mobile keyboard (numeric with decimal point)
- Parse display value by removing non-digit/decimal characters before conversion
- Update parent state only on blur to avoid re-rendering during typing

**Verification:**
- LSP diagnostics show no TypeScript errors
- Committed as: feat: S07 - Create PriceInput component (commit 812bef9)
- Updated PRD: S07 passes: true

---

## 2026-01-19 14:50 - S08: Create ImageUpload component

**What was implemented:**
- Created ImageUpload component in apps/web/src/components/ui/ImageUpload.tsx (194 lines)
- Drag and drop zone with visual feedback (border-primary bg-primary/5 when dragging)
- Click to browse file picker using hidden input with type="file" and ref
- Preview uploaded image using FileReader and data URL
- Upload to Convex file storage flow:
  1. Call products.generateUploadUrl mutation to get temporary upload URL
  2. POST file to URL with Content-Type header
  3. Extract storageId from response JSON
  4. Pass storageId to onChange callback
- File validation: only image/* types, max 5MB size
- Replace existing image with X button (absolute positioned top-right)
- Upload progress indicator: spinning loader overlay with bg-background/80
- Controlled component with value (storageId string) and onChange props
- Disabled state support with opacity and cursor changes
- Toast notifications for success/error states
- lucide-react icons: Upload (drop zone), X (remove button)

**Files changed:**
- apps/web/src/components/ui/ImageUpload.tsx (created, 194 lines)

**Learnings for future iterations:**
- Convex file upload pattern: generateUploadUrl → POST file → extract storageId from response
- FileReader.readAsDataURL creates preview without full upload
- Drag events require preventDefault() to enable custom drop handling
- Hidden file input controlled via ref for programmatic click triggering
- Upload progress overlay uses absolute positioning with semi-transparent background
- Image preview with object-contain maintains aspect ratio
- Accept attribute on input filters file picker to images only
- Stop propagation on remove button click to prevent triggering container click
- Display truncated storageId when no preview available (first 8 chars)

**Verification:**
- LSP diagnostics show no TypeScript errors
- Committed as: feat: S08 - Create ImageUpload component (commit fda3110)
- Updated PRD: S08 passes: true

---

## 2026-01-19 14:15 - S09: Create ProductForm component

**What was implemented:**
- Created ProductForm component in apps/web/src/components/products/ProductForm.tsx (239 lines)
- Implemented comprehensive form with all required fields:
  - Name field (required with validation)
  - Description field (optional textarea)
  - Price field (required, using PriceInput component)
  - Category dropdown (optional, populated from categories.list)
  - Image upload (optional, using ImageUpload component)
- Used TanStack Form with Zod validation schema
- Zod validation for name (min 1 character) and price (min 1, greater than 0)
- Validation errors displayed inline with red text below each field
- Support for both create and edit modes via mode prop
- Mode prop determines: form title, button text, and which mutation to call
- Create mode calls products.create mutation with businessId
- Edit mode calls products.update mutation with productId
- Currency auto-detected from business.defaultLanguage (es->COP, pt->BRL, default->USD)
- Success toast notifications after successful create/update
- Optional onSuccess callback prop for parent component handling
- Card-based layout using shadcn/ui Card components
- Native select element for category dropdown with clean styling
- Native textarea for description with consistent input styling
- Loading state while categories and business data loads

**Files changed:**
- apps/web/src/components/products/ProductForm.tsx (created, 239 lines)

**Learnings for future iterations:**
- TanStack Form field pattern: `<form.Field name="fieldName">{(field) => ...}</form.Field>`
- Zod safeParse returns success boolean and issues array (not errors array)
- Access Zod validation errors: `validated.error.issues[0].message`
- Type casting for Convex Id types: `businessId as Id<"businesses">`
- PriceInput accepts value in centavos (integer) and onChange callback with valueInCents
- ImageUpload accepts value (storageId string) and onChange callback with storageId or undefined
- Currency inference pattern: Use business.defaultLanguage to determine currency for PriceInput
- Native select/textarea elements can be styled consistently with shadcn Input using same classes
- Form submission pattern: e.preventDefault(), e.stopPropagation(), form.handleSubmit()
- Optional fields should be sent as undefined (not empty strings) to Convex mutations
- Mode prop pattern allows single component to handle both create and edit use cases

**Verification:**
- `bun run check-types` passed successfully (0 errors)
- LSP diagnostics show no errors
- Committed as: feat: S09 - Create ProductForm component (commit 04687a2)
- Updated PRD: S09 passes: true

---

## 2026-01-19 14:20 - S10: Create ProductCard component

**What was implemented:**
- Created ProductCard component in apps/web/src/components/products/ProductCard.tsx (156 lines)
- Created Switch component in apps/web/src/components/ui/switch.tsx (22 lines) using Base UI primitives
- Component displays all required product information:
  - Product image thumbnail from Convex storage via products.getImageUrl query
  - Placeholder image ("No image") when no imageId provided
  - Product name with conditional styling (muted when unavailable)
  - Formatted price using Intl.NumberFormat with locale-specific currency formatting
  - Category name (fetched from categories.list and matched by categoryId)
  - Availability badge showing "Unavailable" for unavailable products
- Implemented availability toggle switch at bottom of card
- Switch updates product availability via products.update mutation
- Success toast notifications for availability changes
- Click on card navigates to /products/{productId} edit page
- Checkbox for bulk selection with onSelectChange callback
- Visual indicators for unavailable products:
  - Card opacity reduced to 60% when unavailable
  - Text color muted for product name
  - "Unavailable" badge displayed
- Price formatting with CURRENCY_LOCALES mapping (COP->es-CO, BRL->pt-BR, MXN->es-MX, USD->en-US)
- Converts price from centavos to major units (price / 100) before formatting
- Card hover effect with shadow transition
- Event propagation stopped for checkbox and switch to prevent card click

**Files changed:**
- apps/web/src/components/products/ProductCard.tsx (created, 156 lines)
- apps/web/src/components/ui/switch.tsx (created, 22 lines)

**Learnings for future iterations:**
- Base UI Switch component pattern: SwitchPrimitive.Root with SwitchPrimitive.Thumb
- Switch styling uses data-checked state for conditional styles
- Thumb translation with data-checked:translate-x-4 for toggle animation
- Image loading from Convex storage: useQuery with products.getImageUrl and storageId
- Conditional query pattern: imageId ? { storageId: imageId } : "skip" to avoid unnecessary queries
- formatPrice helper uses Intl.NumberFormat with locale and currency for proper formatting
- Category lookup: find category in categories array by matching _id with categoryId
- Event.stopPropagation() prevents parent onClick when interacting with checkbox/switch
- Card opacity pattern: opacity-60 for unavailable items provides subtle visual feedback
- Checkbox onCheckedChange receives boolean | "indeterminate" - must type guard before using
- Navigate pattern: navigate({ to: `/products/${productId}` }) for type-safe routing

**Verification:**
- `bun run check-types` passed successfully (0 errors)
- LSP diagnostics show no errors
- Committed as: feat: S10 - Create ProductCard component (commit e5ab003)
- Updated PRD: S10 passes: true

---


## 2026-01-19 14:20 - S11: Create ProductTable component

**What was implemented:**
- Created shadcn/ui Table component in apps/web/src/components/ui/table.tsx (125 lines)
- Table component includes: Table, TableHeader, TableBody, TableFooter, TableRow, TableHead, TableCell, TableCaption
- Created ProductTable component in apps/web/src/components/products/ProductTable.tsx (260 lines)
- Implemented all required table columns: checkbox, image thumbnail, name, price, category, availability toggle
- Added sortable columns for name, price, and category with ChevronUp/ChevronDown icons
- Sort state tracked with sortField and sortOrder (asc/desc)
- Click on column header toggles sort order (asc ↔ desc) or changes sort field
- Row click navigation to /products/{productId} edit page
- Checkbox in header for select all functionality
- Select all checkbox shows checked when all products selected, unchecked otherwise
- Visual distinction for unavailable products using opacity-60 and text-muted-foreground
- Availability toggle switch in each row with immediate update via products.update mutation
- Product images loaded via products.getImageUrl query with "No img" placeholder
- Category names resolved from categories.list query
- Created separate ProductTableRow component to avoid violating React hooks rules
- useQuery calls moved to ProductTableRow to comply with rules of hooks
- Price formatting using Intl.NumberFormat with locale-specific currency formatting
- Empty state shown when no products exist ("No products found.")

**Files changed:**
- apps/web/src/components/ui/table.tsx (created, 125 lines)
- apps/web/src/components/products/ProductTable.tsx (created, 260 lines)

**Learnings for future iterations:**
- shadcn/ui Table component structure: Table wraps the entire component, div with overflow-auto for responsive scrolling
- Table styling uses Tailwind CSS classes with hover states, border handling, and padding
- TableHead includes special styling for checkbox columns: [&:has([role=checkbox])]:pr-0
- TableCell has similar checkbox handling for consistent layout
- React hooks rules: Cannot call useQuery inside .map() loop - must extract to separate component
- ProductTableRow pattern: Separate component per row allows hooks to be called at proper level
- Sortable columns pattern: Track sortField and sortOrder state, toggle on header click
- Sort icon display: Conditionally render ChevronUp/ChevronDown based on current sortField
- Sort implementation: Create sorted array with [...products].sort() to avoid mutating original
- Category name resolution: Query categories once, find matching category in sort/render logic
- Select all checkbox: Calculate allSelected as products.every() check
- Base UI Checkbox doesn't support "indeterminate" string value - only boolean checked prop
- Row click with nested interactive elements: Use e.stopPropagation() on nested onClick handlers
- Availability toggle: Inline Switch component with optimistic update feel
- Image loading pattern: useQuery with conditional "skip" when imageId is undefined
- formatPrice helper: Reuse CURRENCY_LOCALES mapping from ProductCard for consistency
- Empty state: Use TableRow with colSpan={6} to span all columns with centered message

**Verification:**
- `bun run check-types` passed successfully (0 errors)
- Committed as: feat: S11 - Create ProductTable component (commit 40a3621)
- Updated PRD: S11 passes: true

---


## 2026-01-19 14:30 - S12: Create product list page

**What was implemented:**
- Created product list page at apps/web/src/routes/products/index.tsx (309 lines)
- Implemented view toggle between grid (ProductCard) and table (ProductTable) modes
- View mode state managed with useState, toggle buttons with Grid/List icons from lucide-react
- Added comprehensive filter controls:
  - Search input for product name and description (case-insensitive)
  - Category dropdown filter (all categories, uncategorized, or specific category)
  - Availability filter dropdown (all, available only, unavailable only)
- Filter logic uses useMemo to optimize filtering performance
- Integrated ProductCard component for grid view in responsive grid (sm:2, lg:3, xl:4 columns)
- Integrated ProductTable component for table view with full functionality
- Bulk selection state management using Set<Id<"products">>
- handleSelectProduct adds/removes products from selection Set
- handleSelectAll selects all filtered products or clears selection
- Selection banner shows count of selected products with "Clear Selection" button
- Add Product button in header linking to /products/new (with Plus icon)
- Manage Categories button in header linking to /products/categories (with Settings icon)
- Empty state with CTA when no products exist
- Empty state differentiates between "no products at all" vs "no products match filters"
- "Add Your First Product" button shown only when product catalog is truly empty
- Auth protection using Authenticated wrapper component from Convex
- Auto-redirect to /onboarding if user has no businesses
- BusinessSwitcher component integrated in header for multi-tenant support
- Active business ID persisted in localStorage with same pattern as dashboard/settings
- Generated TanStack Router route types for /products/ route

**Files changed:**
- apps/web/src/routes/products/index.tsx (created, 309 lines)
- apps/web/src/routeTree.gen.ts (auto-generated route types)

**Learnings for future iterations:**
- View toggle pattern: Single state variable with "grid" | "table" union type
- Button variant="default" for active view, variant="outline" for inactive
- Filter state management: Separate useState for each filter (search, category, availability)
- useMemo for expensive filtering operations prevents re-computation on every render
- Filter composition: Chain multiple filter conditions (search AND category AND availability)
- Category filter "uncategorized" option: Special case for products without categoryId
- Select behavior: Native select element with consistent styling matches Input component classes
- Bulk selection with Set: Efficient add/delete operations, .has() for checking selection
- Selection banner: Conditional render when selectedProducts.size > 0
- Empty state logic: Check products.length === 0 vs filteredProducts.length === 0
- Grid responsive breakpoints: sm:grid-cols-2, lg:grid-cols-3, xl:grid-cols-4 for optimal layout
- Selected products passed to both ProductCard and ProductTable for consistent selection UI
- onSelectChange callback prop pattern allows parent to manage selection state
- TanStack Router generation must run after creating new route files
- Route generation command: bunx @tanstack/router-cli generate in apps/web directory

**Verification:**
- `bun run check-types` passed successfully (0 errors)
- Generated route types successfully
- Committed as: feat: S12 - Create product list page (commit 625a037)
- Updated PRD: S12 passes: true

---


## 2026-01-19 14:35 - S13: Create add product page

**What was implemented:**
- Created add product page at apps/web/src/routes/products/new.tsx (97 lines)
- Page wrapped with Authenticated component for auth protection
- Renders ProductForm component in "create" mode
- Passes businessId prop to ProductForm from active business state
- Back button linking to /products with ArrowLeft icon
- Button uses variant="ghost" and size="sm" for subtle appearance
- onSuccess callback navigates user to /products list after successful creation
- ProductForm handles form validation, submission, and toast notifications
- Product available field defaults to true (set in ProductForm component)
- Same active business ID pattern as products list and dashboard
- Retrieves active business from localStorage or defaults to first business
- Auto-redirects to /onboarding if user has no businesses
- BusinessSwitcher integrated in header for multi-tenant support
- Card layout with CardHeader and CardTitle for consistent UI
- Loading state shown while businesses query loads
- Generated TanStack Router route types for /products/new

**Files changed:**
- apps/web/src/routes/products/new.tsx (created, 97 lines)
- apps/web/src/routeTree.gen.ts (auto-generated route types)
- apps/web/bun.lockb (lockfile updates from route generation)

**Learnings for future iterations:**
- Reusable form component pattern: ProductForm accepts mode="create" or mode="edit"
- onSuccess callback pattern allows parent route to control post-submission behavior
- Simple navigation: navigate({ to: "/products" }) after successful creation
- ProductForm already has toast success notification, no need to duplicate in parent
- Back button placement: Above Card component provides clear navigation hierarchy
- Arrow icon convention: ArrowLeft for back navigation, Plus for create actions
- Active business pattern is consistent across all product pages
- Same localStorage key ("echo:activeBusinessId") ensures consistent business context
- Route generation resolves TypeScript errors for navigate() type checking

**Verification:**
- `bun run check-types` passed successfully (0 errors)
- Generated route types successfully
- Committed as: feat: S13 - Create add product page (commit 08b448f)
- Updated PRD: S13 passes: true

---


## 2026-01-19 14:40 - S14: Create edit product page

**What was implemented:**
- Created edit product page at apps/web/src/routes/products/$productId.tsx (168 lines)
- Dynamic route using TanStack Router's $productId parameter syntax
- Loaded product data using products.get query with productId parameter
- Route.useParams() hook to extract productId from URL
- Rendered ProductForm in "edit" mode with initialData prop
- initialData populated from loaded product (name, description, price, categoryId, imageId)
- Back button in header linking to /products with ArrowLeft icon
- Delete button in header with Trash2 icon and variant="destructive"
- Cancel button below form to discard changes and navigate back
- Delete confirmation dialog using modal overlay pattern
- Modal shows product name in confirmation message
- Delete button disabled during deletion with "Deleting..." text
- Successful deletion triggers toast and navigation to /products
- Product deletion uses products.deleteProduct mutation (soft delete)
- Loading state shown while product query is loading
- "Product not found" state shown when product query returns null
- BusinessSwitcher integrated in header for multi-tenant support
- Auth protection with Authenticated wrapper
- Generated TanStack Router route types for dynamic route

**Files changed:**
- apps/web/src/routes/products/$productId.tsx (created, 168 lines)
- apps/web/src/routeTree.gen.ts (auto-generated route types)
- apps/web/bun.lockb (lockfile updates)

**Learnings for future iterations:**
- TanStack Router dynamic route syntax: $paramName in filename creates dynamic segment
- Route.useParams() provides type-safe access to URL parameters
- Type cast productId to Id<"products"> for Convex queries: `productId as Id<"products">`
- ProductForm initialData prop: Pass existing product data for edit mode
- Edit form pattern: Load data → show loading → render form with initialData
- Null check for product: Handle both loading (undefined) and not found (null) states
- Delete confirmation flow: State variable controls modal visibility
- isDeleting state prevents duplicate delete operations during mutation
- Modal overlay z-index: Use z-50 to ensure it appears above other content
- Delete button placement: Top-right header position with destructive variant for danger action
- Cancel button placement: Below form provides alternative to save action
- ProductForm handles save button internally, parent only needs Cancel button
- Soft delete pattern: products.deleteProduct sets deleted: true, doesn't remove record
- Success navigation: Both save and delete navigate back to /products list

**Verification:**
- `bun run check-types` passed successfully (0 errors)
- Generated route types successfully
- Committed as: feat: S14 - Create edit product page (commit f0c491b)
- Updated PRD: S14 passes: true

---


## 2026-01-19 14:45 - S15: Add toggle availability to product list

**What was implemented:**
- S15 was already implemented in S10 (ProductCard) and S11 (ProductTable)
- ProductCard.tsx includes handleAvailabilityToggle function (line 70)
- Switch component at bottom of card triggers products.update mutation
- Toast notification on success: "Product marked as available/unavailable"
- ProductTable.tsx includes handleAvailabilityToggle function (line 144)
- Switch component in availability column triggers products.update mutation
- Both components use same toast notification pattern
- No confirmation dialog needed (quick action as specified)
- Visual feedback: Switch state changes immediately (Convex reactive updates)
- Error handling with toast.error for failed updates
- Event propagation stopped to prevent row/card click when toggling

**Files changed:**
- No new files (feature already implemented in S10 and S11)

**Learnings for future iterations:**
- Availability toggle was implemented proactively during ProductCard and ProductTable creation
- This demonstrates good component design: Including common actions directly in the component
- Switch component provides inherent visual feedback through checked state
- Convex reactive queries provide "optimistic update" feel automatically
- No need for explicit optimistic updates when using Convex's real-time reactivity

**Verification:**
- Feature already implemented and verified in S10 and S11
- Updated PRD: S15 passes: true

---

