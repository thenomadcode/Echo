## Codebase Patterns
- Schema tables use `defineTable()` with `v` validators from "convex/values"
- Auth pattern: `authComponent.safeGetAuthUser(ctx)` returns authUser with `userId` property - always check `!authUser || !authUser.userId`
- After auth check, store userId in const: `const userId = authUser.userId;` to avoid TypeScript narrowing issues
- Owner references use `ownerId: v.string()` (not v.id) since authUser.userId is a string
- Timestamps stored as `v.number()` in UTC, populated with `Date.now()` in mutations
- Optional fields use `v.optional(v.type)` wrapper
- Enum-like fields use `v.union(v.literal("value1"), v.literal("value2"))`
- Indexes defined with `.index("indexName", ["field"])` chained after defineTable
- Nested objects use `v.object({ field: v.type })`
- Mutations use `Record<string, unknown>` for update objects to avoid optional field type conflicts
- Uniqueness validation: query by index in loop, append suffix if exists
- Queries return null/empty arrays for unauthorized access; mutations throw errors
- Lib utilities: create under `convex/lib/` using `GenericDatabaseReader<DataModel>` for db access
- Dashboard conversation status: active | escalated | closed (separate from AI state machine)
- Human assignment: assignedTo field with v.string() (user ID from better-auth), null/undefined means AI handling

---

## 2026-01-20 22:11 - S08: Create notification mutations and queries

**What was implemented:**
- Created packages/backend/convex/notifications.ts
- notifications.create internalMutation: creates notification with userId, type, conversationId, read: false
- notifications.list query: returns user's notifications sorted by createdAt desc, default limit 20
- notifications.markRead mutation: sets read to true for specific notification
- notifications.markAllRead mutation: marks all user's unread notifications as read
- notifications.unreadCount query: returns count of unread notifications

**Files changed:**
- packages/backend/convex/notifications.ts (created, 96 lines)

**Verification:**
- Convex dev compiles successfully
- LSP diagnostics: no errors
- bun run check-types: passes
- Committed as: feat: S08 - Create notification mutations and queries (commit f917dc9)

---

## 2026-01-20 22:10 - S07: Create send message as human mutation

**What was implemented:**
- Created packages/backend/convex/messages.ts with sendAsHuman mutation
- Validates conversation exists and is assigned to current user
- Saves message to messages table with sender: "human"
- Uses ctx.scheduler.runAfter to trigger async WhatsApp send
- Created sendToWhatsApp internalMutation for Twilio API integration
- Handles failures gracefully: stores deliveryStatus "failed" with errorMessage
- On success: stores externalId (Twilio SID) and deliveryStatus "sent"

**Files changed:**
- packages/backend/convex/messages.ts (created, 115 lines)

**Learnings:**
- Use ctx.scheduler.runAfter(0, ...) for async operations to avoid blocking mutation
- internalMutation can do external API calls (fetch) in Convex
- Store both success and failure states in message for UI feedback

**Verification:**
- Convex dev compiles successfully
- LSP diagnostics: no errors
- bun run check-types: passes
- Committed as: feat: S07 - Create send message as human mutation (commit 89ad42c)

---

## 2026-01-20 22:08 - S06: Create close and reopen mutations

**What was implemented:**
- Created conversations.close mutation: sets status to 'closed', closedAt to Date.now()
- Created conversations.reopen mutation: sets status to 'active', clears closedAt
- Both mutations validate auth and business ownership
- Both mutations return the updated conversation

**Files changed:**
- packages/backend/convex/conversations.ts (+54 lines)

**Verification:**
- Convex dev compiles successfully
- LSP diagnostics: no errors
- bun run check-types: passes
- Committed as: feat: S06 - Create close and reopen mutations (commit c0869a4)

---

## 2026-01-20 22:07 - S05: Create take over and hand back mutations

**What was implemented:**
- Created conversations.takeOver mutation
- Sets assignedTo to current user's ID, updates lastReadAt
- If status was 'escalated', changes to 'active'
- Validates auth and business ownership
- Created conversations.handBack mutation
- Sets assignedTo to undefined (AI resumes handling)
- Validates conversation is currently assigned to this user
- Both mutations return the updated conversation
- Fixed schema: changed assignedTo and userId from v.id("users") to v.string() since better-auth user table is managed by component

**Files changed:**
- packages/backend/convex/conversations.ts (+55 lines)
- packages/backend/convex/schema.ts (changed v.id("users") to v.string() for assignedTo and notifications.userId)

**Learnings:**
- better-auth creates a "user" table managed by its component, not in our schema
- Use v.string() instead of v.id("user") for user ID references since authUser._id is a string

**Verification:**
- Convex dev compiles successfully
- LSP diagnostics: no errors
- bun run check-types: passes
- Committed as: feat: S05 - Create take over and hand back mutations (commit a87d4f0)

---

## 2026-01-20 22:03 - S04: Create conversation detail and messages queries

**What was implemented:**
- Enhanced conversations.get query with auth validation and order info
- Args: conversationId
- Returns conversation with all fields including escalationReason, assignedTo, status
- Includes related order info if exists (via by_conversation index on orders)
- Validates caller has access to conversation's business
- Created conversations.messages query with pagination
- Args: conversationId, limit (default 100), cursor (optional)
- Returns messages with sender, content, createdAt, mediaUrl, mediaType
- Sort messages by createdAt ascending (oldest first)
- Cursor-based pagination for message history

**Files changed:**
- packages/backend/convex/conversations.ts (+75 lines, modified get query)

**Verification:**
- Convex dev compiles successfully
- LSP diagnostics: no errors
- bun run check-types: passes
- Committed as: feat: S04 - Create conversation detail and messages queries (commit 8fd0a24)

---

## 2026-01-20 22:01 - S03: Create conversation list query with filtering

**What was implemented:**
- Created conversations.list query in packages/backend/convex/conversations.ts
- Args: businessId, status (optional filter), search (optional string), limit (default 50), cursor (optional)
- Returns conversations sorted by lastCustomerMessageAt (most recent first)
- Escalated conversations appear at top regardless of activity time
- Each conversation includes: customerId, lastMessagePreview, lastMessageAt, status, assignedTo, hasUnread
- Support pagination with cursor-based approach
- Filter by status when provided (active, escalated, closed)
- Search by customerId when search term provided
- Include unread indicator (messages after lastReadAt)
- Validates caller has access to business (business.ownerId === authUser._id)

**Files changed:**
- packages/backend/convex/conversations.ts (+95 lines)

**Verification:**
- Convex dev compiles successfully
- LSP diagnostics: no errors
- bun run check-types: passes
- Committed as: feat: S03 - Create conversation list query with filtering (commit 5e9b0a8)

---

## 2026-01-20 21:59 - S02: Create notifications table schema

**What was implemented:**
- Added notifications table to packages/backend/convex/schema.ts
- Fields: userId (v.id("users")), type (union of "escalation" | "new_order"), conversationId (v.id("conversations")), read (v.boolean()), createdAt (v.number())
- Index: by_user on [userId, read, createdAt] for efficient user notification queries

**Files changed:**
- packages/backend/convex/schema.ts (+8 lines)

**Verification:**
- Convex dev confirmed: "Added table indexes: notifications.by_user"
- LSP diagnostics: no errors
- Committed as: feat: S02 - Create notifications table schema (commit 52caa0c)

---

## 2026-01-20 21:55 - S01: Update conversations schema for dashboard features

**What was implemented:**
- Updated conversations table status field from `v.optional(v.string())` to `v.optional(v.union(v.literal("active"), v.literal("escalated"), v.literal("closed")))`
- Added `assignedTo: v.optional(v.id("users"))` - null means AI handling, user ID means human assigned
- Added `lastReadAt: v.optional(v.number())` - for unread message indicator
- Added `closedAt: v.optional(v.number())` - timestamp when conversation was closed
- Added `by_business_status` index on [businessId, status] for efficient filtered queries
- Added `by_status` index on [status] for global status filtering

**Files changed:**
- packages/backend/convex/schema.ts (+23 lines, -2 lines)

**Verification:**
- Convex dev confirmed schema compiles: "Added table indexes: conversations.by_business_status, conversations.by_status"
- LSP diagnostics: no errors on schema.ts
- apps/web tsc --noEmit: passes
- Committed as: feat: S01 - Update conversations schema for dashboard features (commit 3789be5)

---

## 2026-01-20 16:45 - S15: Add order status action handlers to detail page

**What was implemented:**
- Wired up Mark Preparing button to orders.markPreparing mutation
- Wired up Mark Ready button to orders.markReady mutation
- Wired up Mark Delivered button to orders.markDelivered mutation
- Wired up Cancel Order button to orders.cancel mutation with window.confirm dialog
- Toast notifications on success and error using sonner
- Loading state with isProcessing flag and Loader2 spinner
- Buttons disabled while processing
- Query invalidation after successful mutation

**Files changed:**
- apps/web/src/routes/dashboard/orders/$orderId.tsx (added ~90 lines of handlers)

---

## 2026-01-20 16:38 - S14: Create order detail dashboard page

**What was implemented:**
- Created apps/web/src/routes/dashboard/orders/$orderId.tsx with dynamic param
- Protected route with auth pattern
- Fetches order using orders.get query
- Shows 404 state if order not found
- Order header with order # and status badge
- Timestamps section (created, updated, cancelled if applicable)
- Items table with name, quantity, unit price, total price
- Totals section with subtotal, delivery fee, grand total
- Delivery section with type, address, notes
- Customer section with phone and name
- Payment section with method, status, payment link
- Action buttons rendered (not wired up): Mark Preparing, Mark Ready, Mark Delivered, Cancel Order

**Files changed:**
- apps/web/src/routes/dashboard/orders/$orderId.tsx (created)
- apps/web/src/routeTree.gen.ts (updated via router-cli)

---

## 2026-01-20 16:35 - S13: Create orders list dashboard page

**What was implemented:**
- Created apps/web/src/routes/dashboard/orders/index.tsx
- Protected route using Authenticated/Unauthenticated pattern
- Fetches orders using convexQuery with orders.listByBusiness
- Table with columns: Order #, Status, Items Count, Total, Date
- Status badges with color coding per spec
- Status filter dropdown (All + 7 statuses)
- Currency formatting (cents to dollars with Intl.NumberFormat)
- Row click navigates to order detail page
- Empty state with "No orders yet" message

**Files changed:**
- apps/web/src/routes/dashboard/orders/index.tsx (created)
- apps/web/src/routeTree.gen.ts (updated via router-cli)

---

## 2026-01-20 16:28 - S12: Create Stripe webhook handler

**What was implemented:**
- Added POST /webhook/stripe route in http.ts
- Verifies webhook signature using STRIPE_WEBHOOK_SECRET
- Pure JavaScript SHA-256 and HMAC implementation (Convex doesn't have Web Crypto API)
- Handles checkout.session.completed event - updates order status to 'paid' and paymentStatus to 'paid'
- Handles checkout.session.expired event - updates paymentStatus to 'failed'
- Handles payment_intent.payment_failed event - logs failure
- Returns 200 OK for all successfully processed events
- Returns 400 for invalid signatures
- Created updateOrderPaymentStatus internalMutation to update orders by stripeSessionId

**Files changed:**
- packages/backend/convex/http.ts (added ~200 lines)
- packages/backend/convex/orders.ts (added updateOrderPaymentStatus mutation)

**Learnings for future iterations:**
- Convex runtime doesn't have Web Crypto API, need pure JS crypto implementations
- Stripe webhook signature format: t={timestamp},v1={hmac_hex}
- Use by_payment_session index to look up orders by stripeSessionId

---

## 2026-01-20 16:18 - S11: Create payment link generation action

**What was implemented:**
- Created orders.generatePaymentLink action
- Validates order exists, has items, and is in draft status or payment link expired
- Uses Stripe API to create checkout session with order items as line items
- Sets currency from order.currency (lowercased for Stripe)
- Includes orderId in session metadata for webhook reconciliation
- Sets success_url and cancel_url to /dashboard/orders/{orderId}
- Stores stripeSessionId, paymentLinkUrl, paymentLinkExpiresAt on order
- Returns the payment link URL
- Handles Stripe API errors with descriptive messages
- Created internal helpers: getOrderForPayment (internalQuery) and updatePaymentLinkInternal (internalMutation)

**Files changed:**
- packages/backend/convex/orders.ts (added ~145 lines)
- packages/backend/convex/_generated/api.d.ts (auto-generated)

**Learnings for future iterations:**
- Convex actions use ctx.runQuery and ctx.runMutation with internal.module.function for internal functions
- Stripe API uses form-urlencoded body with nested bracket notation for arrays
- Need to run `bunx convex codegen` to regenerate internal API types when adding new internal functions
- OrderItem type helper avoids implicit any in forEach loops

---

## 2026-01-20 16:05 - S10: Add payment environment variables

**What was implemented:**
- Added STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, STRIPE_PUBLISHABLE_KEY to packages/env/src/server.ts
- All Stripe env vars are optional (z.string().optional())
- Created packages/backend/.env.local.example with placeholder values and comment

**Files changed:**
- packages/env/src/server.ts (added 3 lines)
- packages/backend/.env.local.example (created)

---

## 2026-01-20 16:02 - S09: Create order queries

**What was implemented:**
- Created orders.get: returns single order by ID
- Created orders.getByConversation: returns most recent order for conversation
- Created orders.getByOrderNumber: returns order by human-readable number
- Created orders.listByBusiness: lists orders with optional status filter and pagination
- All queries validate caller has access to business via authComponent
- Pagination uses cursor-based approach with take(limit + 1) pattern

**Files changed:**
- packages/backend/convex/orders.ts (added 122 lines, now imports query and authComponent)

---

## 2026-01-20 15:58 - S08: Create order status update mutations

**What was implemented:**
- Created orders.markPreparing: transitions confirmed/paid -> preparing
- Created orders.markReady: transitions preparing -> ready
- Created orders.markDelivered: transitions ready -> delivered
- All mutations validate current status allows transition
- All mutations return updated order

**Files changed:**
- packages/backend/convex/orders.ts (added 66 lines)

---

## 2026-01-20 15:56 - S07: Create order cancel mutation

**What was implemented:**
- Created orders.cancel mutation
- Args: orderId, reason (optional)
- Only allows cancellation if status is 'draft' or 'confirmed'
- Throws error for paid/preparing/ready/delivered orders
- Sets cancelledAt and stores cancellationReason

**Files changed:**
- packages/backend/convex/orders.ts (added 27 lines)

---

## 2026-01-20 15:54 - S06: Create order payment method mutation

**What was implemented:**
- Created orders.setPaymentMethod mutation
- Args: orderId, paymentMethod (card|cash)
- If 'cash' selected, updates status to 'confirmed' (ready for fulfillment)
- If 'card' selected, keeps status as 'draft' (awaiting payment link)

**Files changed:**
- packages/backend/convex/orders.ts (added 24 lines)

---

## 2026-01-20 15:52 - S05: Create order delivery mutation

**What was implemented:**
- Created orders.setDeliveryInfo mutation
- Args: orderId, deliveryType, deliveryAddress (optional), deliveryNotes (optional), contactPhone (optional)
- Validates delivery address required when deliveryType is 'delivery'
- Clears deliveryAddress when deliveryType is 'pickup'
- Updates contactPhone if provided

**Files changed:**
- packages/backend/convex/orders.ts (added 38 lines)

---

## 2026-01-20 15:48 - S04: Create order item mutations

**What was implemented:**
- Created orders.addItem mutation: adds item or increments quantity if exists
- Created orders.removeItem mutation: removes item from order
- Created orders.updateItemQuantity mutation: updates quantity, removes if <= 0
- All mutations validate order exists and is in 'draft' status
- All mutations validate product exists and belongs to business
- All mutations recalculate subtotal and total (including deliveryFee)
- All mutations update updatedAt timestamp

**Files changed:**
- packages/backend/convex/orders.ts (expanded from 79 to 205 lines)

**Learnings for future iterations:**
- Use `typeof order.items` for items array type to match existing schema
- Total calculation includes deliveryFee: `subtotal + (order.deliveryFee ?? 0)`
- Default quantity parameter: `args.quantity ?? 1`

---

## 2026-01-20 15:42 - S03: Create orders.create mutation

**What was implemented:**
- Created packages/backend/convex/orders.ts with orders.create mutation
- Validates business exists
- Validates all products exist, belong to the business, and are not deleted
- Looks up product prices and names server-side
- Calculates unitPrice and totalPrice for each item
- Calculates subtotal as sum of all totalPrice values
- Generates unique orderNumber using the lib/orderNumber utility
- Creates order with status 'draft', paymentStatus 'pending', defaults to 'pickup' and 'cash'
- Gets currency from first product, falls back to 'USD'

**Files changed:**
- packages/backend/convex/orders.ts (created, 75 lines)

**Learnings for future iterations:**
- Use explicit type annotation for items array to satisfy Convex insert types
- Default values for enums (deliveryType, paymentMethod) set at creation time
- Currency derived from first product's currency field

---

## 2026-01-20 15:38 - S02: Create order number generation utility

**What was implemented:**
- Created packages/backend/convex/lib/orderNumber.ts with generateOrderNumber function
- Function accepts db context and businessId
- Derives 3-letter prefix from business name (first 3 letters uppercase, falls back to "BIZ" if short)
- Queries existing orders for the business to find max sequential number
- Generates format: ORD-{prefix}-{number} (e.g., ORD-BUR-001234)
- 6-digit zero-padded sequential number

**Files changed:**
- packages/backend/convex/lib/orderNumber.ts (created, 50 lines)

**Learnings for future iterations:**
- Use `GenericDatabaseReader<DataModel>` from convex/server for typed db access in utility functions
- Import types from `../_generated/dataModel` for Id<"tableName"> types
- Query-then-process pattern for sequential number generation is safe for order numbers (low collision risk)

---

## 2026-01-19 21:25 - S03: Receive customer message via webhook

**What was implemented:**
- Created HTTP GET endpoint at /webhook/whatsapp for Meta/Twilio webhook verification
  - Verifies hub.verify_token against WEBHOOK_VERIFY_TOKEN environment variable
  - Returns challenge for successful verification
- Created HTTP POST endpoint at /webhook/whatsapp for receiving messages
  - Handles both JSON and form-urlencoded payloads (Twilio uses form data)
  - Extracts recipient phone number from payload
  - Looks up business by phone number using by_phone index
  - Uses TwilioWhatsAppProvider.parseWebhook() to parse message
  - Calls processIncomingMessage internal mutation
  - Returns 200 OK immediately for fast webhook response
- Created whatsapp.processIncomingMessage internal mutation in webhook.ts
  - Creates channelId format: whatsapp:{customerPhone}:{businessId}
  - Creates new conversation or updates existing one via by_channel index
  - Updates lastCustomerMessageAt on existing conversations
  - Stores message in messages table with sender: "customer"
  - Handles message types: text, image, voice, document via mediaType
- Created whatsapp.getBusinessByPhoneNumber internal mutation
  - Looks up WhatsApp connection by phone number
  - Returns business credentials and provider info
- Fixed twilio.ts to remove Node.js-specific crypto import (not needed for current verification)
- Replaced Buffer.from() with btoa() for base64 encoding (Web API compatible)

**Files changed:**
- packages/backend/convex/http.ts (expanded from 10 to 107 lines)
- packages/backend/convex/integrations/whatsapp/webhook.ts (created, 111 lines)
- packages/backend/convex/integrations/whatsapp/twilio.ts (removed crypto import, replaced Buffer with btoa)
- packages/backend/convex/_generated/api.d.ts (auto-generated)

**Learnings for future iterations:**
- Convex HTTP actions use httpAction from _generated/server, not convex/server
- Nested module paths use dots in API: internal.integrations.whatsapp.webhook.functionName
- Convex runtime doesn't support Node.js crypto module - use Web Crypto API or format validation only
- Form-urlencoded webhooks need URLSearchParams parsing: new URLSearchParams(await request.text())
- Return 200 OK quickly for webhooks to avoid timeouts - process async if needed
- channelId pattern enables finding conversations across channels

**Verification:**
- Convex codegen passes successfully
- LSP diagnostics show no errors on new/modified backend files
- Pre-existing errors in dashboard.tsx and settings.tsx are unrelated to S03
- Committed as: feat: S03 - Receive customer message via webhook (commit 0c05eab)
- Updated PRD: S03 passes: true

---


**What was implemented:**
- Added `businesses.list` query that returns all businesses owned by authenticated user
- Query uses the `by_owner` index for efficient lookups by ownerId
- Returns empty array for unauthenticated users
- Added `businesses.get` query that returns a single business by businessId
- Validates ownership before returning business data
- Returns null for unauthenticated users or unauthorized access attempts
- Imported query function from Convex server module

**Files changed:**
- packages/backend/convex/businesses.ts (added 43 lines, lines 134-175)
- packages/backend/convex/_generated/api.d.ts (auto-generated to include businesses module)
- AGENTS.md (added note about preferring existing shadcn/ui components)

**Learnings for future iterations:**
- When using `authUser.userId` after null check, store it in a const to avoid TypeScript type narrowing issues
- Pattern: `const userId = authUser.userId;` then use `userId` in queries
- Queries should return null or empty arrays for unauthorized/unauthenticated users rather than throwing errors
- This allows graceful handling on the client side
- Auto-generated Convex API files should be committed as they reflect the actual module exports

**Verification:**
- `bun run check-types` passed successfully
- LSP diagnostics show no errors
- Committed as: feat: S03 - Create business queries (commit 703fefb)

---


**What was implemented:**
- Created complete businesses table schema in packages/backend/convex/schema.ts
- Defined all required fields: name, slug, type (union of 4 business types)
- Defined all optional fields: description, logoUrl, address, aiGreeting
- Added localization fields: defaultLanguage, timezone (defaults will be set in mutations)
- Implemented nested businessHours object with open, close, days fields
- Added ownerId for user ownership tracking (using v.string() per auth pattern)
- Added createdAt and updatedAt timestamp fields
- Created two indexes: by_owner (for listing user's businesses) and by_slug (for unique slug lookup)

**Files changed:**
- packages/backend/convex/schema.ts (added 42 lines)

**Learnings for future iterations:**
- Auth pattern discovered: `authComponent.safeGetAuthUser(ctx)` returns authUser object with `userId` as string, so ownerId fields should use `v.string()` not `v.id("users")`
- Convex schemas don't support default values - these must be handled in mutation layer
- Convex doesn't enforce uniqueness at schema level - must validate in mutations using indexes
- Type-safe enums created using `v.union(v.literal("val1"), v.literal("val2"))`
- Schema files benefit from grouping comments for organization of large table definitions
- Business hours stored as object with time strings (HH:mm format) and days array (0-6)

**Verification:**
- `bun run check-types` passed successfully
- Committed as: feat: S01 - Create businesses table schema (commit 5c50b91)

---
## 2026-01-16 13:40 - S02: Create business mutations

**What was implemented:**
- Created businesses.create mutation with name, type, and optional fields (description, logoUrl, address)
- Implemented generateSlug() helper function to convert business name to kebab-case slug
- Added slug uniqueness validation using by_slug index with automatic suffix incrementing
- Set ownerId from authUser.userId with proper null checking
- Applied default values: defaultLanguage='en', timezone='UTC'
- Created businesses.update mutation accepting businessId and all updatable fields
- Implemented ownership validation ensuring only business owner can update
- Auto-updates updatedAt timestamp on all mutations

**Files changed:**
- packages/backend/convex/businesses.ts (created, 132 lines)

**Learnings for future iterations:**
- Must check both `!authUser` AND `!authUser.userId` since userId can be null/undefined
- Slug generation regex patterns require inline comments explaining the pattern (Priority 3 necessary comments)
- For update mutations, use `Record<string, unknown>` instead of `Partial<typeof business>` to avoid type issues with optional fields
- Uniqueness check pattern: query with index, loop until no match found, append suffix if needed
- Convex mutations throw errors which propagate to client - no need for custom error objects

---

## 2026-01-16 - S04 & S05: Create sign up and login pages

**What was implemented:**
- Created /signup route (apps/web/src/routes/signup.tsx) using TanStack Router file-based routing
- Created /login route (apps/web/src/routes/login.tsx) using TanStack Router file-based routing
- Added Google OAuth button to SignUpForm component with Better-Auth social signin
- Added Google OAuth button to SignInForm component with Better-Auth social signin
- Integrated Google logo SVG inline for OAuth buttons
- Added visual separator ("Or continue with") between email/password and OAuth options
- Updated form redirect logic (currently redirects to /dashboard; will update to /onboarding in S06)
- Generated route types using @tanstack/router-cli
- Both pages properly link to each other (signup -> login and login -> signup)

**Files changed:**
- apps/web/src/routes/signup.tsx (created, 17 lines)
- apps/web/src/routes/login.tsx (created, 17 lines)
- apps/web/src/components/sign-up-form.tsx (added Google OAuth, 50 lines added)
- apps/web/src/components/sign-in-form.tsx (added Google OAuth, 50 lines added)
- apps/web/src/routeTree.gen.ts (auto-generated route types)

**Learnings for future iterations:**
- TanStack Router requires generating route types via CLI: `bunx @tanstack/router-cli generate`
- Route types are auto-generated in `src/routeTree.gen.ts` and must be committed
- Better-Auth social signin uses `authClient.signIn.social({ provider, callbackURL })`
- Google OAuth can be triggered before route exists; callbackURL just needs to be a valid path
- For S04/S05, temporarily redirected signup to /dashboard; will update to /onboarding in S06 when that route exists
- Login redirects to /dashboard; dashboard will handle redirecting to /onboarding if user has no businesses (cleaner separation of concerns)
- Type-safe navigation with TanStack Router only allows navigating to defined routes
- Google logo inline SVG is better than importing external assets for simple icons

**Verification:**
- `bunx tsc --noEmit` in apps/web passed successfully (0 errors)
- Route generation completed without errors
- Committed as: feat: S04 - Create sign up page (commit 93c38ec)
- Updated PRD: S04 passes: true, S05 passes: true

---

## 2026-01-16 16:30 - S06: Create onboarding page for business creation

**What was implemented:**
- Created /onboarding route (apps/web/src/routes/onboarding.tsx) with protected authentication
- Used Convex's Authenticated/Unauthenticated/AuthLoading components for auth flow
- Implemented business creation form with required fields (name, type) and optional fields (description, logoUrl, address)
- Added real-time slug preview that updates as user types business name using generateSlug helper
- Native HTML select element for business type dropdown (restaurant, pharmacy, retail, other)
- Native textarea for description field
- Progress indicator showing "Step 1: Create Your Business"
- Card-based layout using shadcn/ui Card components for clean presentation
- Mobile-responsive layout with container max-width and proper spacing
- Form validation using TanStack Form without separate Zod validator (simplified approach)
- Integrated businesses.create mutation from Convex backend
- Success toast notification and redirect to /dashboard on successful submission
- Generated route types using @tanstack/router-cli

**Files changed:**
- apps/web/src/routes/onboarding.tsx (created, 280 lines)
- apps/web/src/routeTree.gen.ts (auto-generated route types update)

**Learnings for future iterations:**
- TanStack Form validation can work without explicit Zod validators by doing validation in onSubmit
- For optional fields with conditional validation (like URL), use safeParse in onSubmit handler
- Convex's Authenticated/Unauthenticated components provide cleaner auth flow than beforeLoad redirects
- Native HTML select/textarea elements work well and don't require shadcn components for simple use cases
- generateSlug helper provides live preview without needing editable slug field
- Progress indicators can be simple div-based layouts without complex step components
- Card components from shadcn/ui provide excellent structure for multi-section forms
- Route type generation must run after creating new route files
- Comments describing form sections (like "Business Name") are unnecessary - the Label components make intent clear

**Verification:**
- `bun run check-types` passed successfully (0 errors)
- LSP diagnostics show no errors after route generation
- Committed as: feat: S06 - Create onboarding page for business creation (commit f2ac337)
- Updated PRD: S06 passes: true

---

## 2026-01-16 17:00 - S07: Create dashboard page

**What was implemented:**
- Completely rebuilt /dashboard route with proper authentication and business checking
- Used Authenticated/Unauthenticated/AuthLoading pattern from Convex
- Implemented automatic redirect to /onboarding if user has no businesses using useEffect
- Dashboard displays active business (first business from businesses.list query)
- Shows business name as large heading with capitalized business type as subheading
- Created two-column card layout using shadcn/ui Card components
- Business Information card displays type, description (if available), and address (if available)
- Quick Actions card contains button linking to /settings
- Integrated UserMenu component in header area
- Clean, minimal layout with proper spacing and responsive grid
- Created placeholder /settings route to enable TypeScript type-safe navigation
- Generated route types for new settings route

**Files changed:**
- apps/web/src/routes/dashboard.tsx (rebuilt, 119 lines)
- apps/web/src/routes/settings.tsx (created placeholder, 31 lines)
- apps/web/src/routeTree.gen.ts (auto-generated route types update)

**Learnings for future iterations:**
- useEffect with navigate is ideal for conditional redirects based on query results
- Check if query is undefined before checking length to avoid unnecessary renders
- Displaying the first business as "active" is simple MVP approach; business switcher (S09) will enhance this
- Card grid with md:grid-cols-2 provides clean responsive layout without custom breakpoints
- Capitalizing enum values for display: `type.charAt(0).toUpperCase() + type.slice(1)`
- Creating placeholder routes helps avoid TypeScript navigation errors when building incrementally
- Separating DashboardContent into its own component keeps auth logic clean

**Verification:**
- `bun run check-types` passed successfully (0 errors)
- LSP diagnostics show no errors
- Committed as: feat: S07 - Create dashboard page (commit bbdcb8b)
- Updated PRD: S07 passes: true

---

## 2026-01-16 17:45 - S08: Create business settings page

**What was implemented:**
- Completely rebuilt /settings route from placeholder into fully functional settings page
- Used same auth pattern as dashboard (Authenticated/Unauthenticated/AuthLoading)
- Implemented redirect to /onboarding if user has no businesses
- Created comprehensive settings form with four Card sections:
  1. Basic Information: name, description, logoUrl
  2. Localization: defaultLanguage dropdown (en, es, pt), timezone selector
  3. Business Hours: open/close time inputs, days of week checkboxes
  4. AI Configuration: aiGreeting textarea
- Language dropdown with full language names (English, Spanish (Español), Portuguese (Português))
- Timezone selector with 15 common IANA timezones (UTC, Americas, Europe, Asia, Australia)
- Business hours uses native time inputs (HH:mm format) and checkbox grid for days
- Days of week stored as numbers (0=Sunday through 6=Saturday) matching schema
- Smart form submission only sends changed fields to businesses.update mutation
- Success toast notification on save
- Properly typed updateBusiness function with correct return type (Promise<string>)
- Mobile-responsive grid layouts (2 columns for time inputs, 2-4 columns for day checkboxes)

**Files changed:**
- apps/web/src/routes/settings.tsx (expanded from 32 to 420 lines)

**Learnings for future iterations:**
- Convex mutations return the document ID, not void - must type function signatures correctly
- Comparing arrays with JSON.stringify is pragmatic for detecting changes in simple arrays
- Native time inputs work excellently with browser UI, no need for custom time pickers
- Checkbox grids for days of week are more intuitive than multi-select dropdowns
- Smart diffing before mutation reduces unnecessary database writes
- COMMON_TIMEZONES constant provides good UX without overwhelming users
- Card-based sections make complex forms scannable and organized
- Type alias for Business interface improves readability when passing to components

**Verification:**
- `bun run check-types` passed successfully (0 errors)
- LSP diagnostics show no errors
- Committed as: feat: S08 - Create business settings page (commit 166b611)
- Updated PRD: S08 passes: true

---

## 2026-01-16 18:30 - S09: Create business switcher component

**What was implemented:**
- Created business-switcher component (apps/web/src/components/business-switcher.tsx)
- Used shadcn/ui DropdownMenu with Base UI primitives
- Button trigger displays current active business name with ChevronDown icon
- Dropdown lists all user's businesses from businesses.list query
- Each business item shows name (bold) and type (small muted text)
- Active business indicated with Check icon (checkmark) from lucide-react
- Implemented localStorage persistence with key "echo:activeBusinessId"
- Auto-selects first business if no active business is set or stored ID is invalid
- useEffect hook ensures active business is always valid when businesses list changes
- Dropdown includes separator and "Create new business" option with Plus icon
- Clicking "Create new business" navigates to /onboarding
- Integrated into dashboard page header (replaced business name heading)
- Integrated into settings page header (added to flex layout with title)
- Used render prop pattern for DropdownMenuTrigger (Base UI doesn't support asChild)

**Files changed:**
- apps/web/src/components/business-switcher.tsx (created, 90 lines)
- apps/web/src/routes/dashboard.tsx (integrated switcher, removed static business heading)
- apps/web/src/routes/settings.tsx (added switcher to header layout)

**Learnings for future iterations:**
- localStorage access must be guarded with typeof window !== "undefined" for SSR
- useEffect dependency array should include all values used for conditional logic
- Base UI DropdownMenuTrigger uses render prop pattern, not asChild like Radix UI
- Storing business ID in localStorage provides persistence across sessions
- Auto-fallback to first business provides good UX when stored ID becomes invalid
- lucide-react icons (Check, ChevronDown, Plus) integrate seamlessly with components
- Business switcher in header is more scalable than static business name display
- flex-col in dropdown items allows stacking name and metadata

**Patterns added to progress.txt:**
- Use localStorage with SSR-safe initialization: `typeof window !== "undefined"`
- DropdownMenuTrigger render prop: `render={(props) => <Button {...props}>...</Button>}`
- Active item indicator: conditional Check icon based on ID comparison

**Verification:**
- `bun run check-types` passed successfully (0 errors)
- LSP diagnostics show no errors
- Committed as: feat: S09 - Create business switcher component (commit 491aeb6)
- Updated PRD: S09 passes: true

---

## 2026-01-19 16:35 - S01: Create WhatsApp data model

**What was implemented:**
- Created whatsappConnections table in packages/backend/convex/schema.ts
  - Fields: businessId (v.id("businesses")), provider, phoneNumberId, phoneNumber, credentials (nested object with accountSid, authToken, apiKey), verified, createdAt
  - Indexes: by_business [businessId], by_phone [phoneNumber]
- Created conversations table for tracking customer conversations
  - Fields: businessId, customerId, channel, channelId, lastCustomerMessageAt, status (optional), createdAt, updatedAt
  - Indexes: by_business [businessId], by_channel [channelId, businessId]
- Created messages table for individual messages
  - Fields: conversationId, sender, content, externalId (optional), deliveryStatus (optional), mediaUrl (optional), mediaType (optional), createdAt
  - Index: by_conversation [conversationId]

**Files changed:**
- packages/backend/convex/schema.ts (added 41 lines for 3 new tables)

**Learnings for future iterations:**
- WhatsApp BSP credentials stored in nested object for flexibility across providers (Twilio, 360dialog)
- Conversations track channel type (whatsapp, web) and channelId for lookup
- lastCustomerMessageAt enables 24-hour messaging window tracking
- Messages use optional externalId for WhatsApp message ID correlation
- deliveryStatus tracks sent/delivered/read/failed states from webhook updates

**Verification:**
- LSP diagnostics show no TypeScript errors
- Committed as: feat: S01 - Create WhatsApp data model (commit 3760aca)
- Updated PRD: S01 passes: true

---

## 2026-01-19 21:10 - S02: Create BSP abstraction layer

**What was implemented:**
- Created packages/backend/convex/integrations/whatsapp/ directory structure
- Created types.ts (116 lines) with comprehensive WhatsApp BSP abstraction types:
  - WhatsAppProvider interface with sendText, sendImage, sendButtons, sendList, parseWebhook, verifyWebhook methods
  - Button type with id and title fields
  - ListRow type with id, title, description fields
  - ListSection type with title and rows fields
  - MessageResult type with success, messageId, error fields
  - ParsedMessage type with from, content, timestamp, mediaUrl, mediaType, messageType, externalId fields
  - MessageType union: "text" | "image" | "voice" | "document" | "buttons" | "list"
  - WebhookVerification type with valid and challenge fields
  - ProviderCredentials type for multi-provider support
- Created twilio.ts (216 lines) with TwilioWhatsAppProvider class implementing WhatsAppProvider:
  - sendText: Sends plain text via Twilio API
  - sendImage: Sends image with optional caption via MediaUrl
  - sendButtons: Falls back to numbered text options (Twilio requires pre-approved templates for buttons)
  - sendList: Falls back to formatted text sections (same template limitation)
  - parseWebhook: Parses Twilio webhook payload into ParsedMessage
  - verifyWebhook: Validates Twilio X-Twilio-Signature header format
  - computeSignature: Helper for full HMAC-SHA1 signature computation
  - sendTwilioMessage: Private method handling Twilio API HTTP requests with Basic auth

**Files changed:**
- packages/backend/convex/integrations/whatsapp/types.ts (created, 116 lines)
- packages/backend/convex/integrations/whatsapp/twilio.ts (created, 216 lines)

**Learnings for future iterations:**
- Twilio WhatsApp interactive messages (buttons, lists) require pre-approved templates - fallback to text format is practical
- WhatsApp phone numbers must be in E.164 format (e.g., +573001234567)
- Twilio webhooks use X-Twilio-Signature header with HMAC-SHA1 of URL + sorted POST params
- Provider abstraction enables easy switching between Twilio, 360dialog, Meta Cloud API
- MessageType union allows type-safe handling of different WhatsApp message formats
- externalId field in ParsedMessage enables message status tracking via webhooks

**Verification:**
- LSP diagnostics show no TypeScript errors on types.ts and twilio.ts
- Committed as: feat: S02 - Create BSP abstraction layer (commit 3b664ba)
- Updated PRD: S02 passes: true

---

## 2026-01-19 21:37 - S04: Send text response to customer

**What was implemented:**
- Created whatsapp.sendMessage action in packages/backend/convex/integrations/whatsapp/actions.ts
- Action accepts args: conversationId, content, type (text)
- Created loadConversationData internalQuery to load conversation, business, and WhatsApp credentials
- Created storeOutgoingMessage internalMutation to store sent messages
- Integrated TwilioWhatsAppProvider.sendText() for actual message delivery
- Implemented exponential backoff with max 3 retries for rate limit handling (1s, 2s, 4s delays)
- Detects rate limit errors via 429 status code or "rate limit" / "Too Many Requests" strings
- Stores successful messages with sender: "business", externalId from Twilio API, deliveryStatus: "sent"
- Stores failed messages with deliveryStatus: "failed" after all retries exhausted

**Files changed:**
- packages/backend/convex/integrations/whatsapp/actions.ts (created, 152 lines)
- packages/backend/convex/_generated/api.d.ts (auto-generated)

**Learnings for future iterations:**
- Convex actions use ctx.runQuery and ctx.runMutation for database operations
- Internal functions use internal.module.path.functionName syntax
- Rate limit handling requires explicit detection of 429 status or rate limit keywords
- Exponential backoff formula: Math.pow(2, attempt) * 1000 gives 1s, 2s, 4s delays
- Always store failed messages with status to enable retry/debugging later
- sleep() helper implemented with Promise and setTimeout

**Verification:**
- bun run check-types passed successfully
- LSP diagnostics show no errors on actions.ts
- Committed as: feat: S04 - Send text response to customer (commit e2cec92)
- Updated PRD: S04 passes: true

---

## 2026-01-19 22:17 - S05: Send rich messages with buttons and lists

**What was implemented:**
- Extended whatsapp.sendMessage action to support message types: text, buttons, list, image
- Added Convex validators for Button and ListSection types (buttonValidator, listRowValidator, listSectionValidator)
- Updated action args with optional fields: buttons, sections, imageUrl, caption, buttonText
- Implemented validation: buttons array required for buttons type (max 3), sections required for list type, imageUrl required for image type
- Implemented automatic fallback to plain text for all rich message types when API call fails
- Created formatButtonsAsFallback(): converts buttons to numbered list text
- Created formatListAsFallback(): converts sections to formatted text with asterisk-bold titles
- Created formatImageAsFallback(): includes image URL in text message
- Updated storeOutgoingMessage mutation with new fields: messageType, richContent, mediaUrl
- Updated messages table schema with messageType (string) and richContent (JSON-encoded structured data)
- Stores original structured content in richContent as JSON string for reconstruction/analytics
- Tracks usedFallback flag to correctly record messageType as "text" when fallback is used

**Files changed:**
- packages/backend/convex/integrations/whatsapp/actions.ts (expanded from 152 to 279 lines)
- packages/backend/convex/schema.ts (added messageType and richContent fields to messages table)

**Learnings for future iterations:**
- Rich message fallback should be attempted only once per send operation (usedFallback flag)
- Storing structured content as JSON string in richContent enables future analytics/reconstruction
- Convex validators can be composed: listSectionValidator uses listRowValidator via v.array()
- Type casting with `as Button[]` works when Convex validator structure matches TypeScript interface
- WhatsApp button limit (3) should be validated before attempting to send
- Image fallback includes URL in text so customers can still access the image

**Verification:**
- Convex codegen passes successfully (22:16:42)
- LSP diagnostics show no errors on actions.ts and schema.ts
- Pre-existing errors in dashboard.tsx and settings.tsx are unrelated to S05
- Committed as: feat: S05 - Send rich messages with buttons and lists (commit ef52aff)
- Updated PRD: S05 passes: true

---

## 2026-01-19 22:20 - S06: Handle WhatsApp 24-hour messaging window

**What was implemented:**
- Created packages/backend/convex/integrations/whatsapp/window.ts with:
  - isWithin24HourWindow(lastCustomerMessageAt) - checks if within 24h window
  - getWindowExpiresAt(lastCustomerMessageAt) - returns expiration timestamp
  - getWindowRemainingMs(lastCustomerMessageAt) - returns remaining ms in window
- Created packages/backend/convex/integrations/whatsapp/templates.ts with:
  - MessageTemplate and TemplateVariable interfaces
  - RE_ENGAGEMENT_TEMPLATE - re-engagement template with {{1}}=business name, {{2}}=context
  - ORDER_UPDATE_TEMPLATE - order status template with {{1}}=customer, {{2}}=order#, {{3}}=status
  - renderTemplate() - renders template with variable substitution
  - getTemplate() - retrieves template by name
- Updated sendMessage action in actions.ts:
  - Added type: "template" as valid message type
  - Added templateName and templateVariables arguments
  - Check isWithin24HourWindow before sending non-template messages
  - Throws error outside 24h window unless type is "template"
  - Template case renders template with provided variables
- Created packages/backend/convex/conversations.ts with queries:
  - get(conversationId) - returns conversation with windowExpiresAt computed field
  - listByBusiness(businessId) - lists all conversations with windowExpiresAt
  - getWithMessages(conversationId, limit?) - returns conversation with messages and windowExpiresAt
- Verified lastCustomerMessageAt already updated in processIncomingMessage (webhook.ts line 48)

**Files changed:**
- packages/backend/convex/integrations/whatsapp/window.ts (created, 25 lines)
- packages/backend/convex/integrations/whatsapp/templates.ts (created, 61 lines)
- packages/backend/convex/integrations/whatsapp/actions.ts (modified, added template support and 24h check)
- packages/backend/convex/conversations.ts (created, 57 lines)
- packages/backend/convex/_generated/api.d.ts (auto-generated)

**Learnings for future iterations:**
- WhatsApp 24h window uses customer's lastCustomerMessageAt timestamp + 24 hours
- Template variables are 1-indexed per WhatsApp Business API spec: {{1}}, {{2}}, etc.
- getWindowExpiresAt returns null if no customer message yet (window never opened)
- Convex queries can add computed fields by spreading document and adding new properties
- Template rendering should provide default values for optional variables

**Verification:**
- Convex codegen passes successfully
- LSP diagnostics show no errors on all new/modified files
- Pre-existing errors in dashboard.tsx and settings.tsx are unrelated to S06
- Committed as: feat: S06 - Handle WhatsApp 24-hour messaging window (commit aae5f0c)
- Updated PRD: S06 passes: true

---

## 2026-01-19 22:25 - S07: Process webhook status updates

**What was implemented:**
- Extended /webhook/whatsapp POST handler in http.ts to detect status update payloads vs message payloads
- Added TwilioWhatsAppProvider.isStatusUpdate() static method to detect status callbacks (has MessageStatus and MessageSid, no Body)
- Added TwilioWhatsAppProvider.parseStatusUpdate() method to parse status webhooks into StatusUpdate type
- Created StatusUpdate interface and DeliveryStatus type ("sent" | "delivered" | "read" | "failed" | "undelivered") in types.ts
- Added ErrorCode and ErrorMessage fields to TwilioWebhookPayload interface
- Created whatsapp.updateMessageStatus internal mutation in webhook.ts:
  - Looks up message by externalId using new by_external_id index
  - Updates deliveryStatus in database
  - Stores errorCode and errorMessage for failed/undelivered messages
  - Logs failed deliveries with console.error for debugging
- Added by_external_id index to messages table in schema.ts for efficient lookup
- Added errorCode and errorMessage optional fields to messages table for failure tracking
- Refactored http.ts POST handler into handleStatusUpdate() and handleIncomingMessage() helpers for clarity

**Files changed:**
- packages/backend/convex/http.ts (expanded from 111 to 145 lines, refactored into helper functions)
- packages/backend/convex/integrations/whatsapp/twilio.ts (added isStatusUpdate and parseStatusUpdate methods)
- packages/backend/convex/integrations/whatsapp/types.ts (added StatusUpdate interface and DeliveryStatus type)
- packages/backend/convex/integrations/whatsapp/webhook.ts (added updateMessageStatus mutation)
- packages/backend/convex/schema.ts (added by_external_id index, errorCode, errorMessage fields)

**Learnings for future iterations:**
- Twilio status callbacks have MessageStatus and MessageSid fields but no Body field - use this to distinguish from message webhooks
- Status values from Twilio: sent, delivered, read, failed, undelivered
- Failed/undelivered messages include ErrorCode (e.g., 30003) and ErrorMessage fields
- Using a static method for payload type detection (isStatusUpdate) avoids needing credentials for detection
- parseStatusUpdate can use a dummy provider instance since it only parses payload, doesn't send

**Verification:**
- Convex codegen passes successfully
- LSP diagnostics show no errors on all modified files
- Committed as: feat: S07 - Process webhook status updates
- Updated PRD: S07 passes: true

---

## 2026-01-19 22:30 - S08: Create WhatsApp connection settings page

**What was implemented:**
- Created packages/backend/convex/integrations/whatsapp/settings.ts with:
  - getConnectionStatus query - returns connection status, provider, phone, verified flag, lastMessageAt
  - saveCredentials mutation - stores/updates WhatsApp BSP credentials
  - markVerified internalMutation - marks connection as verified after test
  - getConnectionForTest internalQuery - loads connection for action
  - testConnection action - validates Twilio credentials via API call
- Created apps/web/src/routes/settings_.whatsapp.tsx (flat route for /settings/whatsapp):
  - Connection status card with visual indicator (green CheckCircle2 / red XCircle)
  - Setup instructions with numbered steps and links to Twilio docs
  - Webhook URL display with copy-to-clipboard button
  - Form with provider dropdown (Twilio), Account SID, Auth Token, Phone Number fields
  - Test Connection button (disabled until credentials saved)
  - Save Credentials button
  - Toast feedback for save/test operations
  - Business switcher integration
- Updated routeTree.gen.ts with new route

**Files changed:**
- packages/backend/convex/integrations/whatsapp/settings.ts (created, 217 lines)
- apps/web/src/routes/settings_.whatsapp.tsx (created, 375 lines)
- apps/web/src/routeTree.gen.ts (updated)
- packages/backend/convex/_generated/api.d.ts (auto-generated)

**Learnings for future iterations:**
- TanStack Router nested routes require parent to render <Outlet /> - use flat route pattern (settings_.whatsapp.tsx) to avoid this
- Flat route naming: use underscore (settings_.whatsapp.tsx) to create /settings/whatsapp without nesting
- Convex actions can test external APIs (Twilio) and then call mutations to update state
- internalMutation/internalQuery bypass auth for internal use but must be called from actions
- Connection test pattern: fetch Twilio account endpoint to verify credentials before marking verified

**Browser Test Results:**
- Navigate to /settings/whatsapp - PASSED (page renders with correct title)
- Connection status indicator visible - PASSED (shows red X for no connection)
- Form with provider dropdown and fields - PASSED (all 4 fields visible)
- Webhook URL in copyable format - PASSED (text input + copy button)
- Test Connection button present - PASSED (disabled until credentials saved)

**Verification:**
- Convex codegen passes successfully
- LSP diagnostics show no errors on new files
- Browser tests all pass
- Committed as: feat: S08 - Create WhatsApp connection settings page (commit c894d1e)
- Updated PRD: S08 passes: true

---

## 2026-01-20 11:40 - S01: Create AI data model and update conversations schema

**What was implemented:**
- Created aiLogs table in packages/backend/convex/schema.ts with fields:
  - conversationId (v.id("conversations"))
  - messageId (v.id("messages"))
  - intent (v.object with type, optional query, items, action, item, topic fields)
  - prompt, response, model (strings)
  - tokensUsed, latencyMs, createdAt (numbers)
- Added by_conversation index on aiLogs for efficient lookup by conversation
- Updated conversations table with new AI Conversation Engine fields:
  - state: union of 7 states (idle, browsing, ordering, confirming, payment, completed, escalated)
  - detectedLanguage: optional string for customer's language
  - pendingOrder: optional object with items array (productQuery, quantity, optional productId, price) and total
  - escalationReason: optional string for human handoff context

**Files changed:**
- packages/backend/convex/schema.ts (+55 lines)

**Learnings for future iterations:**
- Intent object structure designed to accommodate all intent types from S02 (greeting, product_question, order_start, etc.)
- pendingOrder items include productQuery string for fuzzy matching plus optional productId for resolved matches
- State machine uses union of literals for type-safe conversation state tracking
- All new fields are optional to maintain backward compatibility with existing conversations

**Verification:**
- Convex codegen passed successfully
- LSP diagnostics show no errors on schema.ts
- Committed as: feat: S01 - Create AI data model and update conversations schema (commit 5a00bf3)
- Updated PRD: S01 passes: true

---

## 2026-01-20 11:45 - S02: Create AI provider abstraction and types

**What was implemented:**
- Created packages/backend/convex/ai/types.ts with comprehensive AI provider abstraction
- AIProvider interface with complete(params) method returning CompleteResult
- Message type with role (system|user|assistant) and content (string)
- CompleteParams type with messages, systemPrompt, temperature, maxTokens, responseFormat
- CompleteResult type with content, tokensUsed, model fields
- Intent union type with 8 variants:
  - GreetingIntent, ProductQuestionIntent (with query), OrderStartIntent (with items)
  - OrderModifyIntent (with action, item), BusinessQuestionIntent (with topic)
  - EscalationRequestIntent, SmallTalkIntent, UnknownIntent
- OrderItem type with productQuery and quantity
- OrderAction type: add | remove | change_quantity
- AIResponse type with response, intent, shouldEscalate, detectedLanguage
- SerializedIntent type for database storage compatibility
- serializeIntent() and parseIntent() helper functions for type conversion

**Files changed:**
- packages/backend/convex/ai/types.ts (created, 159 lines)

**Learnings for future iterations:**
- Intent types use discriminated union pattern with BaseIntent interface
- SerializedIntent type mirrors aiLogs.intent schema structure for database compatibility
- Helper functions serializeIntent/parseIntent enable type-safe conversion between runtime types and database format
- Intent examples in comments help classify customer messages during implementation

**Verification:**
- LSP diagnostics show no errors on types.ts
- tsc --noEmit passes in apps/web
- Committed as: feat: S02 - Create AI provider abstraction and types (commit 96c54d8)
- Updated PRD: S02 passes: true

---

## 2026-01-20 11:50 - S03: Implement OpenAI provider

**What was implemented:**
- Created packages/backend/convex/ai/providers/openai.ts with OpenAIProvider class implementing AIProvider interface
- Constructor accepts optional apiKey and model, defaults to process.env.OPENAI_API_KEY and gpt-4o-mini
- Implemented complete() method calling OpenAI chat completions API via fetch
- Handles JSON response format via OpenAI's "json_object" response_format type
- Descriptive error handling with specific messages for 401/429/5xx errors
- Factory function createOpenAIProvider() for convenient instantiation

**Files changed:**
- packages/backend/convex/ai/providers/openai.ts (created, 163 lines)

**Learnings for future iterations:**
- OpenAI uses "json_object" as the response_format type value for JSON outputs
- process.env.OPENAI_API_KEY works in Convex actions (env vars accessible at runtime)
- Using fetch() directly (like TwilioWhatsAppProvider) is cleaner than SDK for simple API calls
- OpenAI error responses have nested structure: { error: { message, type, code } }
- Always guard response.json() in try-catch since it can throw on invalid JSON

**Verification:**
- LSP diagnostics show no errors on openai.ts
- bun run check-types passes
- Committed as: feat: S03 - Implement OpenAI provider (commit 5765286)
- Updated PRD: S03 passes: true

---

## 2026-01-20 11:50 - S04: Create language detection function

**What was implemented:**
- Created packages/backend/convex/ai/language.ts with detectLanguage action
- Action accepts message string and returns language code: "es", "pt", or "en"
- Uses lightweight prompt with gpt-4o-mini for classification
- Truncates input to 200 chars for fast processing
- Temperature set to 0 for deterministic responses
- maxTokens set to 5 to minimize latency
- Handles edge cases: empty messages, detection failures
- Defaults to "en" (English) if detection fails or is ambiguous
- Handles alternate responses like "spanish", "portuguese", "english" in addition to codes

**Files changed:**
- packages/backend/convex/ai/language.ts (created, 58 lines)

**Learnings for future iterations:**
- Convex actions use action() from _generated/server with handler returning Promise
- Low maxTokens (5) and temperature (0) optimize for speed in classification tasks
- Input truncation (200 chars) sufficient for language detection while keeping latency low
- Graceful fallback on errors ensures system remains functional even if AI provider fails

**Verification:**
- LSP diagnostics show no errors on language.ts
- bun run check-types passes
- Committed as: feat: S04 - Create language detection function
- Updated PRD: S04 passes: true

---

## 2026-01-20 11:52 - S05: Implement intent classification function

**What was implemented:**
- Created packages/backend/convex/ai/intent.ts with classifyIntent action
- Action accepts: message (string), conversationHistory (Message[]), productNames (string[])
- Uses structured JSON output (responseFormat: "json") for reliable intent extraction
- Prompt includes available products list for fuzzy matching with misspellings
- Extracts entities per intent type:
  - product_question: query string
  - order_start: items array with productQuery and quantity (default 1)
  - order_modify: action (add/remove/change_quantity) and item
  - business_question: topic (hours/location/delivery/payment)
- Includes last 5 conversation messages for context
- mapToIntent() function converts AI response to typed Intent object
- validateOrderAction() ensures valid action enum values
- Graceful fallback to "unknown" intent on parse errors

**Files changed:**
- packages/backend/convex/ai/intent.ts (created, 143 lines)

**Learnings for future iterations:**
- Convex validators for arrays: v.array(v.object({...})) works for typed arrays
- JSON response format requires explicit examples in prompt for consistent structure
- Limiting conversation history (last 5 messages) balances context vs token cost
- Type mapping functions ensure AI output conforms to TypeScript types
- Default values in mapping (quantity: 1, action: "add") handle missing fields gracefully

**Verification:**
- LSP diagnostics show no errors on intent.ts
- bun run check-types passes
- Committed as: feat: S05 - Implement intent classification function
- Updated PRD: S05 passes: true

---

## 2026-01-20 11:55 - S06: Create system prompt builder

**What was implemented:**
- Created packages/backend/convex/ai/prompts.ts with buildSystemPrompt function
- Accepts BuildSystemPromptParams: business info, products list, conversation state, detected language
- Business section includes: name, type, address, business hours (formatted with day names)
- Products section formats each product: name, price (converted from cents), description
- Filters to only show available products
- formatPrice() helper converts cents to display format with currency symbols (USD, COP, BRL, MXN)
- Conversation state context explains current state to AI
- Language instruction in target language (en/es/pt)
- Configurable AI tone from business.aiTone
- 6 rules for AI behavior: only real products, admit uncertainty, offer human help, be concise
- Suggested greeting included when state is "idle" and aiGreeting is configured
- Exports types: BusinessInfo, Product, BuildSystemPromptParams, ConversationState, LanguageCode

**Files changed:**
- packages/backend/convex/ai/prompts.ts (created, 133 lines)

**Learnings for future iterations:**
- Prices stored in cents (integer) must be divided by 100 for display
- Record<number, string> works well for day-of-week mapping (0-6)
- Separating prompt into sections with ## headers improves AI comprehension
- Language instructions in target language reinforce the desired response language
- Filtering products by availability prevents AI from mentioning unavailable items

**Verification:**
- LSP diagnostics show no errors on prompts.ts
- bun run check-types passes
- Committed as: feat: S06 - Create system prompt builder
- Updated PRD: S06 passes: true

---

## 2026-01-20 11:58 - S07: Implement response generation function

**What was implemented:**
- Created packages/backend/convex/ai/response.ts with generateResponse action
- Accepts: intent, conversationHistory, businessContext, products, language, conversationState
- Uses buildSystemPrompt() to create context-aware system prompt
- buildContextInstruction() adds intent-specific guidance to prompt:
  - greeting: friendly welcome
  - product_question: includes matching products from database
  - order_start: confirms items and looks up prices
  - order_modify: acknowledges change
  - business_question: uses business info
  - escalation_request: acknowledges and offers human
  - small_talk: brief friendly response
  - unknown: asks for clarification
- Temperature 0.7 for natural conversation, maxTokens 500 for responses
- getFallbackResponse() provides localized fallbacks in en/es/pt for all intent types
- Validation helpers for language and conversation state
- Uses last 10 conversation messages for context

**Files changed:**
- packages/backend/convex/ai/response.ts (created, 247 lines)

**Learnings for future iterations:**
- Context instructions appended to system prompt help AI focus on current task
- Fallback responses in all supported languages ensure graceful degradation
- Product matching uses case-insensitive search on name and description
- Type casting needed when Convex validators don't exactly match TypeScript types
- Record<LanguageCode, Record<string, string>> provides clean fallback lookup structure

**Verification:**
- LSP diagnostics show no errors on response.ts
- bun run check-types passes
- Committed as: feat: S07 - Implement response generation function
- Updated PRD: S07 passes: true

---

## 2026-01-20 12:02 - S08: Implement escalation detection function

**What was implemented:**
- Created packages/backend/convex/ai/escalation.ts with detectEscalation function
- Accepts: message (string), conversationHistory (Message[]), failureCount (number)
- Returns EscalationResult: { shouldEscalate: boolean, reason: string }
- Explicit escalation phrases in en/es/pt: "talk to person", "human help", "hablar con alguien", etc.
- Urgent keywords: "urgent", "urgente", "emergency", "asap"
- Frustration keywords in en/es/pt: "angry", "frustrated", "furioso", "irritado", etc.
- Failure threshold: 3 consecutive AI failures triggers escalation
- calculateFrustrationScore() analyzes:
  - Current message frustration keywords (+1 each)
  - Recent conversation history keywords (+0.5 each)
  - Multiple exclamation marks (+0.5)
  - All caps messages (+1)
- Score >= 2 triggers frustration escalation
- Reasons included: explicit request, urgent matter, frustrated customer, AI failures

**Files changed:**
- packages/backend/convex/ai/escalation.ts (created, 133 lines)

**Learnings for future iterations:**
- Pure function (no Convex action/mutation) for stateless escalation detection
- Multilingual keyword lists support LATAM market (Spanish, Portuguese)
- Frustration scoring combines immediate message + conversation history
- All-caps detection needs length check to avoid false positives on short messages
- Exclamation count >= 3 indicates urgency/frustration

**Verification:**
- LSP diagnostics show no errors on escalation.ts
- bun run check-types passes
- Committed as: feat: S08 - Implement escalation detection function
- Updated PRD: S08 passes: true

---

## 2026-01-20 12:05 - S09: Create main processMessage orchestrator

**What was implemented:**
- Created packages/backend/convex/ai/process.ts with processMessage action
- processMessage orchestrates the full AI conversation flow:
  1. loadContext internalQuery: loads conversation, business, products, messages
  2. detectLanguage: called on first message or when language not set
  3. classifyIntent: classifies customer intent
  4. detectEscalation: checks if human handoff needed
  5. generateResponse: generates AI response based on context
  6. State update: determines new conversation state based on intent
  7. Logging: stores response message and logs to aiLogs table
- updateConversation internalMutation: updates language and state
- logAIInteraction internalMutation: logs AI interaction metrics
- storeMessage internalMutation: stores AI response message
- determineNewState(): maps intents to state transitions (order_start->ordering, product_question->browsing)
- Returns ProcessMessageResult matching AIResponse type
- Uses api.ai.* for public actions (language, intent, response)
- Uses internal.ai.process.* for internal queries/mutations

**Files changed:**
- packages/backend/convex/ai/process.ts (created, 260 lines)
- packages/backend/convex/_generated/api.d.ts (auto-generated)

**Learnings for future iterations:**
- Public actions called with api.module.function, internal functions with internal.module.function
- Convex codegen must run to update _generated/api.d.ts when adding new modules
- Actions can call other actions via ctx.runAction(api.module.action, args)
- InternalQuery/Mutation used for database operations within actions
- satisfies operator validates return type matches interface
- Type casting needed for conversation state from optional to union type

**Verification:**
- Convex codegen passes successfully
- LSP diagnostics show no errors on process.ts
- bun run check-types passes
- Committed as: feat: S09 - Create main processMessage orchestrator
- Updated PRD: S09 passes: true

---

## 2026-01-20 12:08 - S10: Handle order intent state transitions

**What was implemented:**
- Extended updateConversation to accept pendingOrder and escalationReason
- Added pendingOrderItemValidator and pendingOrderValidator for type-safe order handling
- handleOrderIntent() processes order_start and order_modify intents:
  - order_start: creates new pendingOrder with matched products
  - order_modify add: adds item to order or increments quantity if exists
  - order_modify remove: removes item from order with graceful message if not found
  - order_modify change_quantity: placeholder for quantity changes
- findMatchingProduct() matches product queries to catalog:
  - Exact name match (case-insensitive)
  - Partial name match (product name contains query)
  - Reverse partial match (query contains product name)
- calculateOrderTotal() computes order total from matched prices
- determineNewState() updated: order_modify transitions idle->ordering
- Products matched to orders include productId and price for totals

**Files changed:**
- packages/backend/convex/ai/process.ts (expanded from 271 to 395 lines)

**Learnings for future iterations:**
- PendingOrder items need productId to track resolved product matches
- Three-tier product matching (exact, partial, reverse) handles variations
- Order total stored in cents for consistency with product prices
- Return message from handleOrderIntent for graceful "item not in order" responses
- State transitions should handle order_modify from idle state gracefully

**Verification:**
- Convex codegen passes successfully
- LSP diagnostics show no errors
- bun run check-types passes
- Committed as: feat: S10 - Handle order intent state transitions
- Updated PRD: S10 passes: true

---

## 2026-01-20 12:10 - S11: Handle escalation and conversation handoff

**What was implemented:**
- Added notifyEscalation internal mutation to process.ts:
  - Updates conversation state to "escalated"
  - Stores escalationReason in conversation
  - Logs escalation event with business ID, customer ID, reason
- Updated processMessage to check for escalated state at start:
  - Returns localized message if conversation already escalated
  - Prevents AI from generating new responses for escalated conversations
- Updated processMessage escalation flow:
  - When shouldEscalate is true, calls notifyEscalation
  - Sets newState to "escalated"
  - Escalation reason comes from detectEscalation or defaults to "Customer requested human assistance"
- getEscalatedConversationResponse() provides localized responses in en/es/pt
  - Informs customer that conversation is escalated to human
  - Assures them a team member will respond shortly

**Files changed:**
- packages/backend/convex/ai/process.ts (added ~50 lines)

**Learnings for future iterations:**
- Early return pattern for state-based guards keeps processMessage clean
- console.log in Convex functions shows in deployment logs for debugging
- Escalation notification currently logs - can be extended to send push notifications
- Language-specific responses ensure good UX for LATAM market

**Verification:**
- Convex codegen passes successfully
- LSP diagnostics show no errors
- bun run check-types passes
- Committed as: feat: S11 - Handle escalation and conversation handoff
- Updated PRD: S11 passes: true

---

## 2026-01-20 12:12 - S12: Create AI settings page

**What was implemented:**
- Extended businesses schema with aiTone and aiEscalationKeywords fields
- Created packages/backend/convex/ai/settings.ts with:
  - getSettings query: returns AI config (aiTone, aiGreeting, aiEscalationKeywords)
  - updateSettings mutation: updates AI configuration for business
  - Both validate ownership via authComponent
- Created apps/web/src/routes/settings_.ai.tsx page:
  - Uses flat route pattern for /settings/ai
  - Authenticated/Unauthenticated/AuthLoading pattern
  - BusinessSwitcher integration
  - TanStack Form for form management
- Form fields:
  - AI Tone/Personality: text input for custom tone description
  - Custom Greeting Message: textarea for greeting message
  - Escalation Keywords: comma-separated input
- Created apps/web/src/components/ui/textarea.tsx component
- Save button calls updateSettings with toast feedback
- Settings loaded on mount via useQuery and populated to form

**Files changed:**
- packages/backend/convex/schema.ts (+2 lines for new fields)
- packages/backend/convex/ai/settings.ts (created, 74 lines)
- apps/web/src/routes/settings_.ai.tsx (created, 202 lines)
- apps/web/src/components/ui/textarea.tsx (created, 17 lines)
- apps/web/src/routeTree.gen.ts (auto-generated)

**Learnings for future iterations:**
- Flat route pattern (settings_.ai.tsx) creates /settings/ai without requiring Outlet in parent
- Escalation keywords stored as string array, converted to/from comma-separated for UI
- useEffect with form.setFieldValue populates form when settings load
- Textarea component follows same styling pattern as Input for consistency

**Browser tests (manual verification required):**
- Navigate to /settings/ai: page should render with title
- Form renders with tone, greeting, escalation fields
- Save button visible and clickable

**Verification:**
- Convex codegen passes successfully
- LSP diagnostics show no errors
- bun run check-types passes
- Committed as: feat: S12 - Create AI settings page
- Updated PRD: S12 passes: true

---

## 2026-01-20 12:15 - S13: Create AI usage stats component

**What was implemented:**
- Added getUsageStats query to packages/backend/convex/ai/settings.ts:
  - Aggregates from aiLogs table for the business's conversations
  - Filters to last 30 days
  - Returns: totalTokens, totalConversations, avgLatencyMs, estimatedCostUsd
  - Cost calculation: $0.00015 per 1K tokens (gpt-4o-mini rate)
- Created apps/web/src/components/ai/usage-stats.tsx:
  - Displays stats in 4-column grid
  - Uses lucide-react icons (Zap, MessageSquare, Activity, DollarSign)
  - StatCard subcomponent for consistent stat display
  - Loading and error states handled
- Integrated UsageStats into /settings/ai page below Save button

**Files changed:**
- packages/backend/convex/ai/settings.ts (+52 lines)
- apps/web/src/components/ai/usage-stats.tsx (created, 82 lines)
- apps/web/src/routes/settings_.ai.tsx (+3 lines for import and usage)

**Learnings for future iterations:**
- aiLogs doesn't have direct business index, so query via conversations first
- Set for unique conversation counting avoids duplicates
- Cost estimation uses gpt-4o-mini pricing ($0.15 per 1M tokens)
- Grid layout (2 cols mobile, 4 cols desktop) works well for stats cards

**Browser tests (manual verification required):**
- Navigate to /settings/ai: usage stats section visible
- Stats show token count, conversation count, latency, and cost

**Verification:**
- Convex codegen passes successfully
- LSP diagnostics show no errors
- bun run check-types passes
- Committed as: feat: S13 - Create AI usage stats component
- Updated PRD: S13 passes: true

---


## 2026-01-20 15:35 - S01: Create orders schema and data model

**What was implemented:**
- Created orders table in packages/backend/convex/schema.ts
- Added businessId (Id<businesses>) and conversationId (Id<conversations>) relationships
- Added orderNumber string field for human-readable order identification
- Added status union type: draft, confirmed, paid, preparing, ready, delivered, cancelled
- Added items array with productId, name, quantity, unitPrice, totalPrice per item
- Added pricing fields: subtotal, deliveryFee (optional), total, currency
- Added deliveryType union: delivery, pickup
- Added deliveryAddress and deliveryNotes optional fields
- Added contactPhone and contactName fields
- Added paymentMethod union: card, cash
- Added paymentStatus union: pending, paid, failed, refunded
- Added Stripe payment fields: paymentLinkUrl, paymentLinkExpiresAt, stripeSessionId
- Added fulfillment fields: estimatedReadyTime, notes
- Added timestamps: createdAt, updatedAt, cancelledAt, cancellationReason
- Created indexes: by_business [businessId, status, createdAt], by_conversation [conversationId], by_number [orderNumber], by_payment_session [stripeSessionId]

**Files changed:**
- packages/backend/convex/schema.ts (+54 lines for orders table)

**Learnings for future iterations:**
- Orders table follows same pattern as conversations: relationships via v.id(), timestamps as v.number()
- Composite index by_business includes status and createdAt for efficient filtered queries
- Items stored as array of objects - denormalized product name/price to capture values at order time
- stripeSessionId index enables webhook reconciliation when payment completes
- All prices stored in smallest currency unit (centavos) as integers per AGENTS.md

**Verification:**
- Convex codegen passes successfully
- LSP diagnostics show no errors on schema.ts
- Committed as: feat: S01 - Create orders schema and data model (commit 7828f11)
- Updated PRD: S01 passes: true

---
