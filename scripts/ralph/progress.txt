## Codebase Patterns

### Convex Schema Patterns
- Use `v` from `convex/values` for type validators
- All tables define `createdAt` and `updatedAt` as `v.number()` (UTC timestamps)
- Multi-tenant: All business-specific tables have `businessId: v.id("businesses")` or `v.string()`
- Indexes follow pattern: `.index("by_[field]", ["field1", "field2"])`
- Relationships use `v.id("tableName")` for foreign keys
- Common optional fields use `v.optional(v.type())`
- Nested objects use `v.object({ ... })`
- Unions for enums: `v.union(v.literal("a"), v.literal("b"))`

### Backend Query/Mutation Patterns
- Import from `"./_generated/server"`
- Use `query({ args: {...}, handler: async (ctx) => {...} })`
- Use `mutation({ args: {...}, handler: async (ctx, args) => {...} })`
- Always define args with validators, even if empty: `args: {}`

---

## 2026-01-30 20:53 - US-001
- Implemented productVariants table schema in packages/backend/convex/schema.ts
- Added all required fields: productId, name, sku, price, inventoryQuantity, option1-3 Name/Value pairs, imageId, externalVariantId, available, position, createdAt, updatedAt
- Added optional fields: compareAtPrice, costPrice, barcode, weight, weightUnit, requiresShipping, lastSyncAt
- Created indexes: by_product, by_sku, by_external_id
- Files changed: packages/backend/convex/schema.ts
- **Learnings for future iterations:**
  - Convex schema uses `v.id("tableName")` for foreign key references (not just v.string())
  - Product variants follow Shopify-compatible model: up to 3 option name/value pairs
  - Weight units stored as enum: kg, g, lb, oz
  - All prices stored in smallest currency unit (centavos/cents) as integers
  - Soft delete pattern: use `available: v.boolean()` instead of hard deletes
---

## 2026-01-30 20:56 - US-002
- Updated products table schema in packages/backend/convex/schema.ts:
  - Added hasVariants boolean field (default: false)
  - Expanded source field to support 'manual' | 'shopify' | 'woocommerce' | 'tiendanube'
  - Renamed shopifyProductId to externalProductId
  - Renamed lastShopifySyncAt to lastSyncAt
  - Updated index from by_shopify_id to by_external_id with [businessId, source, externalProductId]
- Updated all Shopify integration files:
  - packages/backend/convex/integrations/shopify/mutations.ts (upsertProduct, upsertProductWithStats, markProductsUnavailable, deleteConnectionAndClearProducts)
  - packages/backend/convex/integrations/shopify/products.ts (importProducts, syncProducts)
  - packages/backend/convex/integrations/shopify/webhooks.ts (handleWebhook)
- Updated all AI files to use new field names:
  - packages/backend/convex/ai/agentPrompt.ts
  - packages/backend/convex/ai/response.ts
  - packages/backend/convex/ai/agent.ts
  - packages/backend/convex/ai/prompts.ts
  - packages/backend/convex/ai/process.ts
- **Learnings for future iterations:**
  - When renaming schema fields, must update:
    1. Schema definition
    2. All mutations using the field
    3. All queries/filters using withIndex
    4. TypeScript interfaces in AI/integration code
  - The hasVariants field is now required on all product inserts (defaults to false for existing Shopify imports)
  - E-commerce provider source is now generic, supporting future integrations beyond Shopify
  - Compound indexes require all fields in the index definition when querying
---

## 2026-01-30 21:08 - US-003
- Updated orders table schema in packages/backend/convex/schema.ts:
  - Added variantId field (optional v.id("productVariants"))
  - Added variantName field (optional v.string())
  - Added sku field (optional v.string())
- Updated OrderItem type in packages/backend/convex/orders/types.ts with same fields
- Files changed: packages/backend/convex/schema.ts, packages/backend/convex/orders/types.ts
- **Learnings for future iterations:**
  - Order items schema changes are backward compatible with existing orders (all new fields are optional)
  - TypeScript types should match Convex schema validators exactly
  - Orders can now track both simple products and specific variants
  - Future mutations will use variantId to fetch price from productVariants table instead of products table
---

## 2026-01-30 21:05 - US-004
- Implemented variant CRUD mutations in packages/backend/convex/variants.ts
- Created 4 mutations: create, update, deleteVariant, adjustInventory
- All mutations validate businessId ownership through parent product
- Fixed products.ts to include hasVariants field in product creation
- Files changed: packages/backend/convex/variants.ts (new), packages/backend/convex/products.ts
- **Learnings for future iterations:**
  - Variant mutations follow same pattern as product mutations (get parent, validate ownership, perform operation)
  - Soft delete pattern: mark available: false instead of hard delete
  - Position field auto-increments if not specified (max position + 1)
  - Inventory adjustments prevent negative values with validation
  - All schema changes require updating existing insert statements
---

## 2026-01-30 21:11 - US-005
- Implemented variant query functions in packages/backend/convex/variants.ts
- Added variants.list query to fetch all variants for a product (sorted by position)
- Added variants.get query to fetch a single variant by ID
- Implemented products.getWithVariants query in packages/backend/convex/products.ts to fetch product with all its variants
- Implemented products.listWithVariants query to fetch product list with variant data and counts
- All queries respect businessId ownership through parent product validation
- Files changed: packages/backend/convex/variants.ts (+62), packages/backend/convex/products.ts (+108)
- **Learnings for future iterations:**
  - Product list queries with variants use Promise.all to fetch variants for each product in parallel
  - Variants are sorted by position field for consistent ordering
  - Auth pattern: check user authentication, get parent entity, verify ownership via isBusinessOwner
  - Query functions return null/empty array instead of throwing errors for unauthorized access
  - Variant count can be calculated during list queries for UI badges/summaries
---
## 2026-01-30 21:15 - US-006
- Created variant generation utility in packages/backend/convex/lib/variantGeneration.ts
- Implemented generateVariantCombinations() function supporting 1-3 options
- Implemented calculateVariantCount() helper for UI display
- Handles all edge cases: single option, two options, three options
- Auto-generates variant names: single option returns value only, multiple options use " / " separator
- TypeScript interfaces: VariantOption (input), GeneratedVariant (output with option1-3 Name/Value pairs)
- Files changed: packages/backend/convex/lib/variantGeneration.ts (new)
- **Learnings for future iterations:**
  - Utility functions for complex logic belong in packages/backend/convex/lib/
  - Shopify-compatible means max 3 options (option1, option2, option3)
  - Variant names follow format: "Value1 / Value2 / Value3" for multi-option, just "Value1" for single option
  - TypeScript interfaces should be exported for reuse in mutations/queries
  - Validation should happen at function entry (throw early for invalid inputs)
  - Combinatorial generation uses nested loops: 1 for single, 2 for double, 3 for triple options
---


## 2026-01-30 21:18 - US-007
- Implemented variant toggle in ProductForm component (apps/web/src/components/products/product-form.tsx)
- Added Switch UI component import and hasVariants field to form state
- Created toggle UI with label "This product has variants" and helpful description
- Implemented conditional rendering using form.Subscribe:
  - When toggle OFF: shows simple product price field (existing behavior)
  - When toggle ON: shows placeholder message for variant options builder (US-008)
- Toggle state persists in form defaultValues
- All acceptance criteria met except browser test (manual verification needed)
- Files changed: apps/web/src/components/products/product-form.tsx (+62, -23 lines)
- **Learnings for future iterations:**
  - Use form.Subscribe with selector to reactively show/hide sections based on form field values
  - Switch component from @/components/ui/switch uses Base UI primitives with checked/onCheckedChange props
  - Conditional form sections should use form.Subscribe, not useState for toggle state
  - Placeholder UI for future features helps visualize the complete user experience
  - Toggle descriptions should explain what enabling the feature does for the user
---
